> æ–‡ç« å¯ä»¥ç™½å«–ï¼Œè€é“ä»¬é¡ºä¾¿å…³æ³¨ä¸€ä¸‹æˆ‘çš„å…¬ä¼—å·ï¼Œæ‰‹åŠ¨æ»‘ç¨½ğŸ¤£ğŸ¤£ &nbsp;
>
> æ¬¢è¿å¤§å®¶å…³æ³¨ï¼š**æ­¦å“¥èŠç¼–ç¨‹**ã€**Javaå¼€å‘å®å…¸**ã€**Javaç§ƒå¤´å“¥**ï¼Œæ‚¨çš„æ”¯æŒï¼Œæ˜¯æˆ‘åˆ›ä½œçš„æŒç»­åŠ¨åŠ›ï¼&nbsp;&nbsp;

![å…¬ä¼—å·äºŒç»´ç ](https://img-blog.csdnimg.cn/20201121225359995.png)

----

# ConcurrentHashMap

ä¼—æ‰€å‘¨çŸ¥ï¼ŒHashMapåœ¨å¤šçº¿ç¨‹æƒ…å†µä¸‹ï¼Œåœ¨putçš„æ—¶å€™ï¼Œæ’å…¥çš„å…ƒç´ è¶…è¿‡äº†å®¹é‡ï¼ˆç”±è´Ÿè½½å› å­å†³å®šï¼‰çš„èŒƒå›´å°±ä¼šè§¦å‘æ‰©å®¹æ“ä½œï¼›è‹¥å­˜åœ¨åŒæ—¶å…¶ä»–çš„å…ƒç´ ä¹Ÿåœ¨è¿›è¡Œputæ“ä½œï¼Œå¦‚æœhashå€¼ç›¸åŒï¼Œå¯èƒ½å‡ºç°åŒæ—¶åœ¨åŒä¸€æ•°ç»„ä¸‹ç”¨é“¾è¡¨è¡¨ç¤ºï¼Œé€ æˆé—­ç¯ï¼Œå¯¼è‡´åœ¨getæ—¶ä¼šå‡ºç°æ­»å¾ªç¯ï¼Œæ‰€ä»¥HashMapæ˜¯çº¿ç¨‹ä¸å®‰å…¨çš„ã€‚é‚£ä¹ˆä»Šå¤©æˆ‘ä»¬å°±æ¥äº†è§£ä¸‹çº¿ç¨‹å®‰å…¨çš„ `ConcurrentHashmap  `ã€‚

## æ•°æ®ç»“æ„

![image](http://note.youdao.com/yws/public/resource/07a596690165d28c75671b1363b80262/xmlnote/51850740F400417A9CC44C5F130C5E53/13525)

> ç”±æ­¤å¯çŸ¥ï¼Œ`ConcurrentHashMap` ä¸ `HashMap` ç±»åŒï¼Œä¹Ÿæ˜¯ç”± æ•°ç»„+é“¾è¡¨+çº¢é»‘æ ‘ æ„æˆã€‚

- Node å®ä½“
> ConcurrentHashMap, key, value, nextå°è£…åˆ°ä¸€ä¸ªé™æ€å†…éƒ¨ç±» `Node` ä¸Šã€‚å®ƒ `å®ç°äº†Map.Entry<K,V>` æ¥å£ã€‚

```java
static class Node<K,V> implements Map.Entry<K,V> {
	// hashå€¼
    final int hash;
    // é”®
    final K key;
    // å€¼
    volatile V val;
    // é“¾è¡¨ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
    volatile Node<K,V> next;
    
    // æ„é€ æ–¹æ³•
    Node(int hash, K key, V val, Node<K,V> next) {
        this.hash = hash;
        this.key = key;
        this.val = val;
        this.next = next;
    }
    
    // è·å–é”®
    public final K getKey()        { return key; }
    // è·å–å€¼
    public final V getValue()      { return val; }
    // è®¡ç®—hashCodeå€¼
    public final int hashCode() {
        return key.hashCode() ^ val.hashCode();
    }
    // é‡å†™toStringæ–¹æ³•
    public final String toString() { return key + "=" + val; }
    
    // ä¸å…è®¸è°ƒç”¨setValueæ–¹æ³•ç›´æ¥æ”¹å˜Nodeçš„valueåŸŸ
    public final V setValue(V newValue) {
        throw new UnsupportedOperationException();
    }
    // æ¯”è¾ƒä¸¤ä¸ªentry
    public final boolean equals(Object o) {
        Object k, v, u; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    (k == key || k.equals(key)) &&
                    (v == (u = val) || v.equals(u)));
    }
    
    // æ ¹æ®å“ˆå¸Œå€¼ä»¥åŠkey æŸ¥æ‰¾å¯¹åº”çš„èŠ‚ç‚¹
    Node<K,V> find(int h, Object k) {
        Node<K,V> e = this;
        if (k != null) {
            do {
                K ek;
                if (e.hash == h &&
                    ((ek = e.key) == k || (ek != null && k.equals(ek))))
                    return e;
            } while ((e = e.next) != null);
        }
        return null;
    }
}
```

**å¯ä»¥çœ‹åˆ°ï¼Œè¿™ä¸ªNode<K,V>[]æ ¸å¿ƒçš„å†…éƒ¨ç±»ï¼Œå®ƒåŒ…è£…äº†key-valueé”®å€¼å¯¹ï¼Œæ‰€æœ‰æ’å…¥ConcurrentHashMapçš„æ•°æ®éƒ½åŒ…è£…åœ¨è¿™é‡Œé¢ã€‚å®ƒä¸HashMapä¸­çš„å®šä¹‰å¾ˆç›¸ä¼¼ï¼Œä½†æ˜¯ä½†æ˜¯æœ‰ä¸€äº›å·®åˆ«å®ƒå¯¹valueå’Œnextå±æ€§è®¾ç½®äº† `volatileåŒæ­¥é”` ; `ä¸å…è®¸è°ƒç”¨setValueæ–¹æ³•ç›´æ¥æ”¹å˜Nodeçš„valueåŸŸ`ï¼Œå®ƒ `å¢åŠ äº†findæ–¹æ³•è¾…åŠ©map.get()æ–¹æ³•` ã€‚**

## æºç åˆ†æ

- æˆå‘˜å±æ€§

```
  // nodeæ•°ç»„æœ€å¤§å®¹é‡ï¼š2^30=1073741824  
  private static final int MAXIMUM_CAPACITY = 1 << 30;  

  // é»˜è®¤åˆå§‹å€¼ï¼Œå¿…é¡»æ˜¯2çš„å¹‚æ•°  
  private static final int DEFAULT_CAPACITY = 6;  

  // æ•°ç»„å¯èƒ½æœ€å¤§å€¼ï¼Œéœ€è¦ä¸toArrayï¼ˆï¼‰ç›¸å…³æ–¹æ³•å…³è”  
  static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;  

  // å¹¶å‘çº§åˆ«ï¼Œé—ç•™ä¸‹æ¥çš„ï¼Œä¸ºå…¼å®¹ä»¥å‰çš„ç‰ˆæœ¬  
  private static final int DEFAULT_CONCURRENCY_LEVEL = 16;  

  // è´Ÿè½½å› å­  
  private static final float LOAD_FACTOR = 0.75f;  

  // é“¾è¡¨è½¬çº¢é»‘æ ‘é˜€å€¼,> 8 é“¾è¡¨è½¬æ¢ä¸ºçº¢é»‘æ ‘  
  static final int TREEIFY_THRESHOLD = 8;  

  // æ ‘è½¬é“¾è¡¨é˜€å€¼ï¼Œå°äºç­‰äº6  
  static final int UNTREEIFY_THRESHOLD = 6;  
 
 // å¯è¢«æ ‘åŒ–çš„æœ€å°è¡¨å®¹é‡ï¼š64
  static final int MIN_TREEIFY_CAPACITY = 64;  

  private static final int MIN_TRANSFER_STRIDE = 16;  

  private static int RESIZE_STAMP_BITS = 16;  

  // 2^15-1ï¼Œhelp resizeçš„æœ€å¤§çº¿ç¨‹æ•°  
  private static final int MAX_RESIZERS = (1 << (32 - RESIZE_STAMP_BITS)) - 1; 

  // 32-16=16ï¼ŒsizeCtlä¸­è®°å½•sizeå¤§å°çš„åç§»é‡  
  private static final int RESIZE_STAMP_SHIFT = 32 - RESIZE_STAMP_BITS;

  // forwarding nodesçš„hashå€¼  
  static final int MOVED     = -1 ;  

  // æ ‘æ ¹èŠ‚ç‚¹çš„hashå€¼  
  static final int TREEBIN   = -2;  

  // ReservationNodeçš„hashå€¼  
  static final int RESERVED  = -3;  

  // å¯ç”¨å¤„ç†å™¨æ•°é‡  
  static final int NCPU = Runtime.getRuntime().availableProcessors();  

  // å­˜æ”¾nodeçš„æ•°ç»„  
  transient volatile Node<K,V>[] table;  

 /**
  * æ§åˆ¶æ ‡è¯†ç¬¦ï¼Œç”¨æ¥æ§åˆ¶tableçš„åˆå§‹åŒ–å’Œæ‰©å®¹çš„æ“ä½œï¼Œä¸åŒçš„å€¼æœ‰ä¸åŒçš„å«ä¹‰  
  * å½“ä¸ºè´Ÿæ•°æ—¶ï¼š-1 ä»£è¡¨æ­£åœ¨åˆå§‹åŒ–ï¼Œ-Nä»£è¡¨æœ‰N-1ä¸ªçº¿ç¨‹æ­£åœ¨è¿›è¡Œæ‰©å®¹  
  * å½“ä¸º0æ—¶ï¼šä»£è¡¨å½“æ—¶çš„tableè¿˜æ²¡æœ‰è¢«åˆå§‹åŒ–  
  * å½“ä¸ºæ­£æ•°æ—¶ï¼šè¡¨ç¤ºåˆå§‹åŒ–æˆ–è€…ä¸‹ä¸€æ¬¡è¿›è¡Œæ‰©å®¹çš„å¤§å°  
  */
  private transient volatile int sizeCtl;  

```

- æ„é€ æ–¹æ³•
```
// ç©ºçš„æ„é€ 
public ConcurrentHashMapDebug() {
}

// å¦‚æœåœ¨å®ä¾‹åŒ–å¯¹è±¡çš„æ—¶å€™æŒ‡å®šäº†å®¹é‡ï¼Œåˆ™åˆå§‹åŒ–sizeCtl
public ConcurrentHashMapDebug(int initialCapacity) {
    if (initialCapacity < 0)
        throw new IllegalArgumentException();
    int cap = ((initialCapacity >= (MAXIMUM_CAPACITY >>> 1)) ?
               MAXIMUM_CAPACITY :
               tableSizeFor(initialCapacity + (initialCapacity >>> 1) + 1));
    this.sizeCtl = cap;
}

// å½“å‡ºå…¥ä¸€ä¸ªMapçš„æ—¶å€™ï¼Œå…ˆè®¾å®šsizeCtlä¸ºé»˜è®¤å®¹é‡ï¼Œåœ¨æ·»åŠ å…ƒç´ 
public ConcurrentHashMapDebug(Map<? extends K, ? extends V> m) {
    this.sizeCtl = DEFAULT_CAPACITY;
    putAll(m);
}

// æŒ‡å®šåˆå§‹åŒ–å¤§å°ä»¥åŠè´Ÿè½½å› å­æ„é€ æ–¹æ³•
public ConcurrentHashMap(int initialCapacity, float loadFactor) {
    this(initialCapacity, loadFactor, 1);
}

/**
 *  æŒ‡å®šåˆå§‹åŒ–å¤§å°ã€è´Ÿè½½å› å­ä»¥åŠå…è®¸å¹¶å‘ä¿®æ”¹çº¿ç¨‹æ•°æ„é€ æ–¹æ³•
 */
public ConcurrentHashMap(int initialCapacity,
                         float loadFactor, int concurrencyLevel) {
    if (!(loadFactor > 0.0f) || initialCapacity < 0 || concurrencyLevel <= 0)
        throw new IllegalArgumentException();
    if (initialCapacity < concurrencyLevel)   // Use at least as many bins
        initialCapacity = concurrencyLevel;   // as estimated threads
    long size = (long)(1.0 + (long)initialCapacity / loadFactor);
    int cap = (size >= (long)MAXIMUM_CAPACITY) ?
        MAXIMUM_CAPACITY : tableSizeFor((int)size);
    this.sizeCtl = cap;
}
```

> å¯ä»¥çœ‹åˆ°ï¼Œä»»ä½•ä¸€ä¸ªæ„é€ æ–¹æ³•éƒ½æ²¡æœ‰å¯¹ tableæ•°ç»„è¿›è¡Œåˆå§‹åŒ–ã€‚å…¶å® tableçš„åˆå§‹åŒ–æ˜¯å†ç¬¬ä¸€æ¬¡putæ“ä½œæ—¶è¿›è¡Œçš„ï¼Œé‚£æˆ‘ä»¬æ¥çœ‹çœ‹åˆå§‹åŒ–æ–¹æ³•ã€‚

```
/**
 * åˆå§‹åŒ–æ•°ç»„tableï¼Œ
 * å¦‚æœsizeCtlå°äº0ï¼Œè¯´æ˜åˆ«çš„æ•°ç»„æ­£åœ¨è¿›è¡Œåˆå§‹åŒ–ï¼Œåˆ™è®©å‡ºæ‰§è¡Œæƒ
 * å¦‚æœsizeCtlå¤§äº0çš„è¯ï¼Œåˆ™åˆå§‹åŒ–ä¸€ä¸ªå¤§å°ä¸ºsizeCtlçš„æ•°ç»„
 * å¦åˆ™çš„è¯åˆå§‹åŒ–ä¸€ä¸ªé»˜è®¤å¤§å°(16)çš„æ•°ç»„
 * ç„¶åè®¾ç½®sizeCtlçš„å€¼ä¸ºæ•°ç»„é•¿åº¦çš„3/4
 */
private final Node<K,V>[] initTable() {
    Node<K,V>[] tab; int sc;
    while ((tab = table) == null || tab.length == 0) {  
        // ç¬¬ä¸€æ¬¡putçš„æ—¶å€™ï¼Œtableè¿˜æ²¡è¢«åˆå§‹åŒ–ï¼Œè¿›å…¥while
        if ((sc = sizeCtl) < 0)                            
        /**
         *  sizeCtlåˆå§‹å€¼ä¸º0ï¼Œ
         *  å½“å°äº0çš„æ—¶å€™è¡¨ç¤ºåœ¨åˆ«çš„çº¿ç¨‹åœ¨åˆå§‹åŒ–è¡¨æˆ–æ‰©å±•è¡¨ Thread.yield();
         */
        // lost initialization race; just spin
        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {    
            /**
             * SIZECTLï¼šè¡¨ç¤ºå½“å‰å¯¹è±¡çš„å†…å­˜åç§»é‡ï¼Œ
             * scè¡¨ç¤ºæœŸæœ›å€¼ï¼Œ
             * -1è¡¨ç¤ºè¦æ›¿æ¢çš„å€¼ï¼Œè®¾å®šä¸º-1è¡¨ç¤ºè¦åˆå§‹åŒ–è¡¨äº†
             */
            try {
                if ((tab = table) == null || tab.length == 0) {
                    int n = (sc > 0) ? sc : DEFAULT_CAPACITY;       
                 // æŒ‡å®šäº†å¤§å°çš„æ—¶å€™å°±åˆ›å»ºæŒ‡å®šå¤§å°çš„Nodeæ•°ç»„ï¼Œå¦åˆ™åˆ›å»ºæŒ‡å®šå¤§å°(16)çš„Nodeæ•°ç»„
                    @SuppressWarnings("unchecked")
                    Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];
                    table = tab = nt;
                    sc = n - (n >>> 2);
                }
            } finally {
                sizeCtl = sc;            
                // åˆå§‹åŒ–åï¼ŒsizeCtlé•¿åº¦ä¸ºæ•°ç»„é•¿åº¦çš„3/4
            }
            break;
        }
    }
    return tab;
}
```

- å­˜å‚¨æ–¹æ³•

 1.  put æ–¹æ³•

     ```java
     /**
      *  å•çº¯çš„è°ƒç”¨putValæ–¹æ³•ï¼Œå¹¶ä¸”putValçš„ç¬¬ä¸‰ä¸ªå‚æ•°è®¾ç½®ä¸ºfalse
      *  å½“è®¾ç½®ä¸ºfalseçš„æ—¶å€™è¡¨ç¤ºè¿™ä¸ªvalueä¸€å®šä¼šè®¾ç½®
      *  trueçš„æ—¶å€™ï¼Œåªæœ‰å½“è¿™ä¸ªkeyçš„valueä¸ºç©ºçš„æ—¶å€™æ‰ä¼šè®¾ç½®
      */
     public V put(K key, V value) {
     	return putVal(key, value, false);
     }
     
     /**
      * å½“æ·»åŠ ä¸€å¯¹é”®å€¼å¯¹çš„æ—¶å€™ï¼Œé¦–å…ˆä¼šå»åˆ¤æ–­ä¿å­˜è¿™äº›é”®å€¼å¯¹çš„æ•°ç»„æ˜¯ä¸æ˜¯åˆå§‹åŒ–äº†ï¼Œ
      * å¦‚æœæ²¡æœ‰çš„è¯å°±åˆå§‹åŒ–æ•°ç»„
      *  ç„¶åé€šè¿‡è®¡ç®—hashå€¼æ¥ç¡®å®šæ”¾åœ¨æ•°ç»„çš„å“ªä¸ªä½ç½®
      * å¦‚æœè¿™ä¸ªä½ç½®ä¸ºç©ºåˆ™ç›´æ¥æ·»åŠ ï¼Œå¦‚æœä¸ä¸ºç©ºçš„è¯ï¼Œåˆ™å–å‡ºè¿™ä¸ªèŠ‚ç‚¹æ¥
      * å¦‚æœå–å‡ºæ¥çš„èŠ‚ç‚¹çš„hashå€¼æ˜¯MOVED(-1)çš„è¯ï¼Œåˆ™è¡¨ç¤ºå½“å‰æ­£åœ¨å¯¹è¿™ä¸ªæ•°ç»„è¿›è¡Œæ‰©å®¹ï¼Œå¤åˆ¶åˆ°æ–°çš„æ•°ç»„ï¼Œåˆ™å½“å‰çº¿ç¨‹ä¹Ÿå»å¸®åŠ©å¤åˆ¶
      * æœ€åä¸€ç§æƒ…å†µå°±æ˜¯ï¼Œå¦‚æœè¿™ä¸ªèŠ‚ç‚¹ï¼Œä¸ä¸ºç©ºï¼Œä¹Ÿä¸åœ¨æ‰©å®¹ï¼Œåˆ™é€šè¿‡synchronizedæ¥åŠ é”ï¼Œè¿›è¡Œæ·»åŠ æ“ä½œ
      *    ç„¶ååˆ¤æ–­å½“å‰å–å‡ºçš„èŠ‚ç‚¹ä½ç½®å­˜æ”¾çš„æ˜¯é“¾è¡¨è¿˜æ˜¯æ ‘
      *    å¦‚æœæ˜¯é“¾è¡¨çš„è¯ï¼Œåˆ™éå†æ•´ä¸ªé“¾è¡¨ï¼Œç›´åˆ°å–å‡ºæ¥çš„èŠ‚ç‚¹çš„keyæ¥ä¸ªè¦æ”¾çš„keyè¿›è¡Œæ¯”è¾ƒï¼Œå¦‚æœkeyç›¸ç­‰ï¼Œå¹¶ä¸”keyçš„hashå€¼ä¹Ÿç›¸ç­‰çš„è¯ï¼Œ
      *          åˆ™è¯´æ˜æ˜¯åŒä¸€ä¸ªkeyï¼Œåˆ™è¦†ç›–æ‰valueï¼Œå¦åˆ™çš„è¯åˆ™æ·»åŠ åˆ°é“¾è¡¨çš„æœ«å°¾
      *    å¦‚æœæ˜¯æ ‘çš„è¯ï¼Œåˆ™è°ƒç”¨putTreeValæ–¹æ³•æŠŠè¿™ä¸ªå…ƒç´ æ·»åŠ åˆ°æ ‘ä¸­å»
      *  æœ€ååœ¨æ·»åŠ å®Œæˆä¹‹åï¼Œä¼šåˆ¤æ–­åœ¨è¯¥èŠ‚ç‚¹å¤„å…±æœ‰å¤šå°‘ä¸ªèŠ‚ç‚¹ï¼ˆæ³¨æ„æ˜¯æ·»åŠ å‰çš„ä¸ªæ•°ï¼‰ï¼Œå¦‚æœè¾¾åˆ°8ä¸ªä»¥ä¸Šäº†çš„è¯ï¼Œ
      *  åˆ™è°ƒç”¨treeifyBinæ–¹æ³•æ¥å°è¯•å°†å¤„çš„é“¾è¡¨è½¬ä¸ºæ ‘ï¼Œæˆ–è€…æ‰©å®¹æ•°ç»„
      */
     final V putVal(K key, V value, boolean onlyIfAbsent) {
         if (key == null || value == null) throw new NullPointerException();// K,Véƒ½ä¸èƒ½ä¸ºç©ºï¼Œå¦åˆ™çš„è¯è·‘å‡ºå¼‚å¸¸
         int hash = spread(key.hashCode());    // å–å¾—keyçš„hashå€¼
         int binCount = 0;    // ç”¨æ¥è®¡ç®—åœ¨è¿™ä¸ªèŠ‚ç‚¹æ€»å…±æœ‰å¤šå°‘ä¸ªå…ƒç´ ï¼Œç”¨æ¥æ§åˆ¶æ‰©å®¹æˆ–è€…è½¬ç§»ä¸ºæ ‘
         for (Node<K,V>[] tab = table;;) {    //
             Node<K,V> f; int n, i, fh;
             if (tab == null || (n = tab.length) == 0)    
                 tab = initTable();    // ç¬¬ä¸€æ¬¡putçš„æ—¶å€™tableæ²¡æœ‰åˆå§‹åŒ–ï¼Œåˆ™åˆå§‹åŒ–table
             else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {    
                 // é€šè¿‡å“ˆå¸Œè®¡ç®—å‡ºä¸€ä¸ªè¡¨ä¸­çš„ä½ç½®å› ä¸ºnæ˜¯æ•°ç»„çš„é•¿åº¦ï¼Œæ‰€ä»¥(n-1)&hashè‚¯å®šä¸ä¼šå‡ºç°æ•°ç»„è¶Šç•Œ
                 if (casTabAt(tab, i, null,        //å¦‚ æœè¿™ä¸ªä½ç½®æ²¡æœ‰å…ƒç´ çš„è¯ï¼Œåˆ™é€šè¿‡casçš„æ–¹å¼å°è¯•æ·»åŠ ï¼Œæ³¨æ„è¿™ä¸ªæ—¶å€™æ˜¯æ²¡æœ‰åŠ é”çš„
                              new Node<K,V>(hash, key, value, null)))        //åˆ›å»ºä¸€ä¸ªNodeæ·»åŠ åˆ°æ•°ç»„ä¸­åŒºï¼Œnullè¡¨ç¤ºçš„æ˜¯ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ä¸ºç©º
                     break;                   // no lock when adding to empty bin
             }
                 /*
                  * å¦‚æœæ£€æµ‹åˆ°æŸä¸ªèŠ‚ç‚¹çš„hashå€¼æ˜¯MOVEDï¼Œåˆ™è¡¨ç¤ºæ­£åœ¨è¿›è¡Œæ•°ç»„æ‰©å¼ çš„æ•°æ®å¤åˆ¶é˜¶æ®µï¼Œ
                  * åˆ™å½“å‰çº¿ç¨‹ä¹Ÿä¼šå‚ä¸å»å¤åˆ¶ï¼Œé€šè¿‡å…è®¸å¤šçº¿ç¨‹å¤åˆ¶çš„åŠŸèƒ½ï¼Œä¸€æ¬¡æ¥å‡å°‘æ•°ç»„çš„å¤åˆ¶æ‰€å¸¦æ¥çš„æ€§èƒ½æŸå¤±
                  */
             else if ((fh = f.hash) == MOVED)    
                 tab = helpTransfer(tab, f);
             else {
                     /*
                      * å¦‚æœåœ¨è¿™ä¸ªä½ç½®æœ‰å…ƒç´ çš„è¯ï¼Œå°±é‡‡ç”¨synchronizedçš„æ–¹å¼åŠ é”ï¼Œ
                      *     å¦‚æœæ˜¯é“¾è¡¨çš„è¯(hashå¤§äº0)ï¼Œå°±å¯¹è¿™ä¸ªé“¾è¡¨çš„æ‰€æœ‰å…ƒç´ è¿›è¡Œéå†ï¼Œ
                      *         å¦‚æœæ‰¾åˆ°äº†keyå’Œkeyçš„hashå€¼éƒ½ä¸€æ ·çš„èŠ‚ç‚¹ï¼Œåˆ™æŠŠå®ƒçš„å€¼æ›¿æ¢åˆ°
                      *         å¦‚æœæ²¡æ‰¾åˆ°çš„è¯ï¼Œåˆ™æ·»åŠ åœ¨é“¾è¡¨çš„æœ€åé¢
                      *  å¦åˆ™ï¼Œæ˜¯æ ‘çš„è¯ï¼Œåˆ™è°ƒç”¨putTreeValæ–¹æ³•æ·»åŠ åˆ°æ ‘ä¸­å»
                      *  
                      *  åœ¨æ·»åŠ å®Œä¹‹åï¼Œä¼šå¯¹è¯¥èŠ‚ç‚¹ä¸Šå…³è”çš„çš„æ•°ç›®è¿›è¡Œåˆ¤æ–­ï¼Œ
                      *  å¦‚æœåœ¨8ä¸ªä»¥ä¸Šçš„è¯ï¼Œåˆ™ä¼šè°ƒç”¨treeifyBinæ–¹æ³•ï¼Œæ¥å°è¯•è½¬åŒ–ä¸ºæ ‘ï¼Œæˆ–è€…æ˜¯æ‰©å®¹
                      */
                 V oldVal = null;
                 synchronized (f) {
                     if (tabAt(tab, i) == f) {        // å†æ¬¡å–å‡ºè¦å­˜å‚¨çš„ä½ç½®çš„å…ƒç´ ï¼Œè·Ÿå‰é¢å–å‡ºæ¥çš„æ¯”è¾ƒ
                         if (fh >= 0) {                // å–å‡ºæ¥çš„å…ƒç´ çš„hashå€¼å¤§äº0ï¼Œå½“è½¬æ¢ä¸ºæ ‘ä¹‹åï¼Œhashå€¼ä¸º-2
                             binCount = 1;            
                             for (Node<K,V> e = f;; ++binCount) {    // éå†è¿™ä¸ªé“¾è¡¨
                                 K ek;
                                 // è¦å­˜çš„å…ƒç´ çš„hashï¼Œkeyè·Ÿè¦å­˜å‚¨çš„ä½ç½®çš„èŠ‚ç‚¹çš„ç›¸åŒçš„æ—¶å€™ï¼Œæ›¿æ¢æ‰è¯¥èŠ‚ç‚¹çš„valueå³å¯
                                 if (e.hash == hash &&        
                                     ((ek = e.key) == key ||
                                      (ek != null && key.equals(ek)))) {
                                     oldVal = e.val;
                                     if (!onlyIfAbsent)        // å½“ä½¿ç”¨putIfAbsentçš„æ—¶å€™ï¼Œåªæœ‰åœ¨è¿™ä¸ªkeyæ²¡æœ‰è®¾ç½®å€¼å¾—æ—¶å€™æ‰è®¾ç½®
                                         e.val = value;
                                     break;
                                 }
                                 Node<K,V> pred = e;
                                 if ((e = e.next) == null) {    // å¦‚æœä¸æ˜¯åŒæ ·çš„hashï¼ŒåŒæ ·çš„keyçš„æ—¶å€™ï¼Œåˆ™åˆ¤æ–­è¯¥èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ˜¯å¦ä¸ºç©ºï¼Œ
                                     pred.next = new Node<K,V>(hash, key,        // ä¸ºç©ºçš„è¯æŠŠè¿™ä¸ªè¦åŠ å…¥çš„èŠ‚ç‚¹è®¾ç½®ä¸ºå½“å‰èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
                                                               value, null);
                                     break;
                                 }
                             }
                         }
                         else if (f instanceof TreeBin) {    // è¡¨ç¤ºå·²ç»è½¬åŒ–æˆçº¢é»‘æ ‘ç±»å‹äº†
                             Node<K,V> p;
                             binCount = 2;
                             // è°ƒç”¨putTreeValæ–¹æ³•ï¼Œå°†è¯¥å…ƒç´ æ·»åŠ åˆ°æ ‘ä¸­å»
                             if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key, value)) != null) {
                                 oldVal = p.val;
                                 if (!onlyIfAbsent)
                                     p.val = value;
                             }
                         }
                     }
                 }
                 if (binCount != 0) {
                     if (binCount >= TREEIFY_THRESHOLD)   
                         // å½“åœ¨åŒä¸€ä¸ªèŠ‚ç‚¹çš„æ•°ç›®è¾¾åˆ°8ä¸ªçš„æ—¶å€™ï¼Œåˆ™æ‰©å¼ æ•°ç»„æˆ–å°†ç»™èŠ‚ç‚¹çš„æ•°æ®è½¬ä¸ºtree
                         treeifyBin(tab, i);    
                     if (oldVal != null)
                         return oldVal;
                     break;
                 }
             }
         }
         addCount(1L, binCount);    // è®¡æ•°
         return null;
     }
     ```

     > æ‰©å®¹è§£æ

     * åŒä¸€ä¸ªèŠ‚ç‚¹çš„ä¸ªæ•°è¶…è¿‡ `8` ä¸ªçš„æ—¶å€™ï¼Œä¼šè°ƒç”¨  `treeifyBin` æ–¹æ³•æ¥çœ‹çœ‹æ˜¯æ‰©å®¹è¿˜æ˜¯è½¬åŒ–ä¸ºä¸€æ£µæ ‘

     * æ¯æ¬¡æ·»åŠ å®Œå…ƒç´ çš„ `addCount` æ–¹æ³•ä¸­ï¼Œä¹Ÿä¼šåˆ¤æ–­å½“å‰æ•°ç»„ä¸­çš„å…ƒç´ æ˜¯å¦è¾¾åˆ°äº† `sizeCtl` çš„é‡ï¼Œè‹¥è¾¾åˆ°åˆ™è°ƒç”¨ `transfer`å»æ‰©å®¹

     ```java
     /**
      * å½“æ•°ç»„é•¿åº¦å°äº64çš„æ—¶å€™ï¼Œæ‰©å¼ æ•°ç»„é•¿åº¦ä¸€å€ï¼Œå¦åˆ™çš„è¯æŠŠé“¾è¡¨è½¬ä¸ºæ ‘
      */
     private final void treeifyBin(Node<K,V>[] tab, int index) {
         Node<K,V> b; int n, sc;
         if (tab != null) {
             System.out.println("treeifyBinæ–¹\t==>æ•°ç»„é•¿ï¼š"+tab.length);
             if ((n = tab.length) < MIN_TREEIFY_CAPACITY)    // MIN_TREEIFY_CAPACITY 64
                 tryPresize(n << 1);   // æ•°ç»„æ‰©å®¹
             else if ((b = tabAt(tab, index)) != null && b.hash >= 0) {
                 synchronized (b) {    // ä½¿ç”¨synchronizedåŒæ­¥å™¨ï¼Œå°†è¯¥èŠ‚ç‚¹å‡ºçš„é“¾è¡¨è½¬ä¸ºæ ‘
                     if (tabAt(tab, index) == b) {
                         TreeNode<K,V> hd = null, tl = null;    // hdï¼šæ ‘çš„å¤´(head)
                         for (Node<K,V> e = b; e != null; e = e.next) {
                             TreeNode<K,V> p =
                                 new TreeNode<K,V>(e.hash, e.key, e.val,
                                                   null, null);
                             if ((p.prev = tl) == null)   // æŠŠNodeç»„æˆçš„é“¾è¡¨ï¼Œè½¬åŒ–ä¸ºTreeNodeçš„é“¾è¡¨ï¼Œå¤´ç»“ç‚¹ä»»ç„¶æ”¾åœ¨ç›¸åŒçš„ä½ç½®
                                 hd = p;    // è®¾ç½®head
                             else
                                 tl.next = p;
                             tl = p;
                         }
                         setTabAt(tab, index, new TreeBin<K,V>(hd));// æŠŠTreeNodeçš„é“¾è¡¨æ”¾å…¥å®¹å™¨TreeBinä¸­
                     }
                 }
             }
         }
     }
     
     /**
      *  æ‰©å®¹è¡¨ä¸ºæŒ‡å¯ä»¥å®¹çº³æŒ‡å®šä¸ªæ•°çš„å¤§å°ï¼ˆæ€»æ˜¯2çš„Næ¬¡æ–¹ï¼‰
      *  å‡è®¾åŸæ¥çš„æ•°ç»„é•¿åº¦ä¸º16ï¼Œåˆ™åœ¨è°ƒç”¨tryPresizeçš„æ—¶å€™ï¼Œsizeå‚æ•°çš„å€¼ä¸º16<<1(32)ï¼Œæ­¤æ—¶sizeCtlçš„å€¼ä¸º12
      *  è®¡ç®—å‡ºæ¥cçš„å€¼ä¸º64,åˆ™è¦æ‰©å®¹åˆ°sizeCtlâ‰¥ä¸ºæ­¢
      *    ç¬¬ä¸€æ¬¡æ‰©å®¹ä¹‹å æ•°ç»„é•¿ï¼š32 sizeCtlï¼š24
      *    ç¬¬äºŒæ¬¡æ‰©å®¹ä¹‹å æ•°ç»„é•¿ï¼š64 sizeCtlï¼š48
      *    ç¬¬äºŒæ¬¡æ‰©å®¹ä¹‹å æ•°ç»„é•¿ï¼š128 sizeCtlï¼š94 --> è¿™ä¸ªæ—¶å€™æ‰ä¼šé€€å‡ºæ‰©å®¹
      */
     private final void tryPresize(int size) {
            /*
             * MAXIMUM_CAPACITY = 1 << 30
             * å¦‚æœç»™å®šçš„å¤§å°å¤§äºç­‰äºæ•°ç»„å®¹é‡çš„ä¸€åŠï¼Œåˆ™ç›´æ¥ä½¿ç”¨æœ€å¤§å®¹é‡ï¼Œ
             * å¦åˆ™ä½¿ç”¨tableSizeForç®—å‡ºæ¥
             * åé¢tableä¸€ç›´è¦æ‰©å®¹åˆ°è¿™ä¸ªå€¼å°äºç­‰äºsizeCtrl(æ•°ç»„é•¿åº¦çš„3/4)æ‰é€€å‡ºæ‰©å®¹
             */
         int c = (size >= (MAXIMUM_CAPACITY >>> 1)) ? MAXIMUM_CAPACITY :
         tableSizeFor(size + (size >>> 1) + 1);
         int sc;
         while ((sc = sizeCtl) >= 0) {
             Node<K,V>[] tab = table; int n;
             //            printTable(tab);    è°ƒè¯•ç”¨çš„
                 /*
                  *  å¦‚æœæ•°ç»„tableè¿˜æ²¡æœ‰è¢«åˆå§‹åŒ–ï¼Œåˆ™åˆå§‹åŒ–ä¸€ä¸ªå¤§å°ä¸ºsizeCtrlå’Œåˆšåˆšç®—å‡ºæ¥çš„cä¸­è¾ƒå¤§çš„ä¸€ä¸ªå¤§å°çš„æ•°ç»„
                  *  åˆå§‹åŒ–çš„æ—¶å€™ï¼Œè®¾ç½®sizeCtrlä¸º-1ï¼Œåˆå§‹åŒ–å®Œæˆä¹‹åæŠŠsizeCtrlè®¾ç½®ä¸ºæ•°ç»„é•¿åº¦çš„3/4
                  *  ä¸ºä»€ä¹ˆè¦åœ¨æ‰©å¼ çš„åœ°æ–¹æ¥åˆå§‹åŒ–æ•°ç»„å‘¢ï¼Ÿè¿™æ˜¯å› ä¸ºå¦‚æœç¬¬ä¸€æ¬¡putçš„æ—¶å€™ä¸æ˜¯putå•ä¸ªå…ƒç´ ï¼Œ
                  *  è€Œæ˜¯è°ƒç”¨putAllæ–¹æ³•ç›´æ¥putä¸€ä¸ªmapçš„è¯ï¼Œåœ¨putALlæ–¹æ³•ä¸­æ²¡æœ‰è°ƒç”¨initTableæ–¹æ³•å»åˆå§‹åŒ–tableï¼Œ
                  *  è€Œæ˜¯ç›´æ¥è°ƒç”¨äº†tryPresizeæ–¹æ³•ï¼Œæ‰€ä»¥è¿™é‡Œéœ€è¦åšä¸€ä¸ªæ˜¯ä¸æ˜¯éœ€è¦åˆå§‹åŒ–tableçš„åˆ¤æ–­
                  */
             if (tab == null || (n = tab.length) == 0) {
                 n = (sc > c) ? sc : c;
                 if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {    // åˆå§‹åŒ–tabçš„æ—¶å€™ï¼ŒæŠŠsizeCtlè®¾ä¸º-1
                     try {
                         if (table == tab) {
                             @SuppressWarnings("unchecked")
                             Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];
                             table = nt;
                             sc = n - (n >>> 2);
                         }
                     } finally {
                         sizeCtl = sc;
                     }
                 }
             }
                 /*
                  *  ä¸€ç›´æ‰©å®¹åˆ°çš„cå°äºç­‰äºsizeCtlæˆ–è€…æ•°ç»„é•¿åº¦å¤§äºæœ€å¤§é•¿åº¦çš„æ—¶å€™ï¼Œåˆ™é€€å‡º
                  *  æ‰€ä»¥åœ¨ä¸€æ¬¡æ‰©å®¹ä¹‹åï¼Œä¸æ˜¯åŸæ¥é•¿åº¦çš„ä¸¤å€ï¼Œè€Œæ˜¯2çš„næ¬¡æ–¹å€
                  */
             else if (c <= sc || n >= MAXIMUM_CAPACITY) {
                 break;    // é€€å‡ºæ‰©å®¹
             }
             else if (tab == table) {
                 int rs = resizeStamp(n);
                     /*
                      *  å¦‚æœæ­£åœ¨æ‰©å®¹Tableçš„è¯ï¼Œåˆ™å¸®åŠ©æ‰©å®¹
                      *  å¦åˆ™çš„è¯ï¼Œå¼€å§‹æ–°çš„æ‰©å®¹
                      *  åœ¨transferæ“ä½œï¼Œå°†ç¬¬ä¸€ä¸ªå‚æ•°çš„tableä¸­çš„å…ƒç´ ï¼Œç§»åŠ¨åˆ°ç¬¬äºŒä¸ªå…ƒç´ çš„tableä¸­å»ï¼Œ
                      *  è™½ç„¶æ­¤æ—¶ç¬¬äºŒä¸ªå‚æ•°è®¾ç½®çš„æ˜¯nullï¼Œä½†æ˜¯ï¼Œåœ¨transferæ–¹æ³•ä¸­ï¼Œå½“ç¬¬äºŒä¸ªå‚æ•°ä¸ºnullçš„æ—¶å€™ï¼Œ
                      *  ä¼šåˆ›å»ºä¸€ä¸ªä¸¤å€å¤§å°çš„table
                      */
                 if (sc < 0) {
                     Node<K,V>[] nt;
                     if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                         sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||
                         transferIndex <= 0)
                         break;
                         /*
                          *  transferçš„çº¿ç¨‹æ•°åŠ ä¸€,è¯¥çº¿ç¨‹å°†è¿›è¡Œtransferçš„å¸®å¿™
                          *  åœ¨transferçš„æ—¶å€™ï¼Œscè¡¨ç¤ºåœ¨transferå·¥ä½œçš„çº¿ç¨‹æ•°
                          */
                     if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))
                         transfer(tab, nt);
                 }
                     /*
                      *  æ²¡æœ‰åœ¨åˆå§‹åŒ–æˆ–æ‰©å®¹ï¼Œåˆ™å¼€å§‹æ‰©å®¹
                      */
                 else if (U.compareAndSwapInt(this, SIZECTL, sc,
                                              (rs << RESIZE_STAMP_SHIFT) + 2)) {
                     transfer(tab, null);
                 }
             }
         }
     }
     
     /**
      *  æŠŠæ•°ç»„ä¸­çš„èŠ‚ç‚¹å¤åˆ¶åˆ°æ–°çš„æ•°ç»„çš„ç›¸åŒä½ç½®ï¼Œæˆ–è€…ç§»åŠ¨åˆ°æ‰©å¼ éƒ¨åˆ†çš„ç›¸åŒä½ç½®
      *  åœ¨è¿™é‡Œé¦–å…ˆä¼šè®¡ç®—ä¸€ä¸ªæ­¥é•¿ï¼Œè¡¨ç¤ºä¸€ä¸ªçº¿ç¨‹å¤„ç†çš„æ•°ç»„é•¿åº¦ï¼Œç”¨æ¥æ§åˆ¶å¯¹CPUçš„ä½¿ç”¨ï¼Œ
      *  æ¯ä¸ªCPUæœ€å°‘å¤„ç†16ä¸ªé•¿åº¦çš„æ•°ç»„å…ƒç´ ,ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœä¸€ä¸ªæ•°ç»„çš„é•¿åº¦åªæœ‰16ï¼Œé‚£åªæœ‰ä¸€ä¸ªçº¿ç¨‹ä¼šå¯¹å…¶è¿›è¡Œæ‰©å®¹çš„å¤åˆ¶ç§»åŠ¨æ“ä½œ
      *  æ‰©å®¹çš„æ—¶å€™ä¼šä¸€ç›´éå†ï¼ŒçŸ¥é“å¤åˆ¶å®Œæ‰€æœ‰èŠ‚ç‚¹ï¼Œæ²¡å¤„ç†ä¸€ä¸ªèŠ‚ç‚¹çš„æ—¶å€™ä¼šåœ¨é“¾è¡¨çš„å¤´éƒ¨è®¾ç½®ä¸€ä¸ªfwdèŠ‚ç‚¹ï¼Œè¿™æ ·å…¶ä»–çº¿ç¨‹å°±ä¼šè·³è¿‡ä»–ï¼Œ
      *  å¤åˆ¶ååœ¨æ–°æ•°ç»„ä¸­çš„é“¾è¡¨ä¸æ˜¯ç»å¯¹çš„ååºçš„
      */
     private final void transfer(Node<K,V>[] tab, Node<K,V>[] nextTab) {
         int n = tab.length, stride;
         if ((stride = (NCPU > 1) ? (n >>> 3) / NCPU : n) < MIN_TRANSFER_STRIDE)    // MIN_TRANSFER_STRIDE ç”¨æ¥æ§åˆ¶ä¸è¦å ç”¨å¤ªå¤šCPU
             stride = MIN_TRANSFER_STRIDE; // subdivide range    //MIN_TRANSFER_STRIDE=16
             /*
              *  å¦‚æœå¤åˆ¶çš„ç›®æ ‡nextTabä¸ºnullçš„è¯ï¼Œåˆ™åˆå§‹åŒ–ä¸€ä¸ªtableä¸¤å€é•¿çš„nextTab
              *  æ­¤æ—¶nextTableè¢«è®¾ç½®å€¼äº†(åœ¨åˆå§‹æƒ…å†µä¸‹æ˜¯ä¸ºnullçš„)
              *  å› ä¸ºå¦‚æœæœ‰ä¸€ä¸ªçº¿ç¨‹å¼€å§‹äº†è¡¨çš„æ‰©å¼ çš„æ—¶å€™ï¼Œå…¶ä»–çº¿ç¨‹ä¹Ÿä¼šè¿›æ¥å¸®å¿™æ‰©å¼ ï¼Œ
              *  è€Œåªæ˜¯ç¬¬ä¸€ä¸ªå¼€å§‹æ‰©å¼ çš„çº¿ç¨‹éœ€è¦åˆå§‹åŒ–ä¸‹ç›®æ ‡æ•°ç»„
              */
         if (nextTab == null) {            // initiating
             try {
                 @SuppressWarnings("unchecked")
                 Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n << 1];
                 nextTab = nt;
             } catch (Throwable ex) {      // try to cope with OOME
                 sizeCtl = Integer.MAX_VALUE;
                 return;
             }
             nextTable = nextTab;
             transferIndex = n;
         }
         int nextn = nextTab.length;
         /*
          *  åˆ›å»ºä¸€ä¸ªfwdèŠ‚ç‚¹ï¼Œè¿™ä¸ªæ˜¯ç”¨æ¥æ§åˆ¶å¹¶å‘çš„ï¼Œå½“ä¸€ä¸ªèŠ‚ç‚¹ä¸ºç©ºæˆ–å·²ç»è¢«è½¬ç§»ä¹‹åï¼Œå°±è®¾ç½®ä¸ºfwdèŠ‚ç‚¹
          *  è¿™æ˜¯ä¸€ä¸ªç©ºçš„æ ‡å¿—èŠ‚ç‚¹
          */
         ForwardingNode<K,V> fwd = new ForwardingNode<K,V>(nextTab);
         boolean advance = true;    // æ˜¯å¦ç»§ç»­å‘å‰æŸ¥æ‰¾çš„æ ‡å¿—ä½
         boolean finishing = false; // to ensure sweep(æ¸…æ‰«) before committing nextTab,åœ¨å®Œæˆä¹‹å‰é‡æ–°åœ¨æ‰«æä¸€éæ•°ç»„ï¼Œçœ‹çœ‹æœ‰æ²¡å®Œæˆçš„æ²¡
         for (int i = 0, bound = 0;;) {
             Node<K,V> f; int fh;
             while (advance) {
                 int nextIndex, nextBound;
                 if (--i >= bound || finishing) {
                     advance = false;
                 }
                 else if ((nextIndex = transferIndex) <= 0) {
                     i = -1;
                     advance = false;
                 }
                 else if (U.compareAndSwapInt
                          (this, TRANSFERINDEX, nextIndex,
                           nextBound = (nextIndex > stride ?
                                        nextIndex - stride : 0))) {
                     bound = nextBound;
                     i = nextIndex - 1;
                     advance = false;
                 }
             }
             if (i < 0 || i >= n || i + n >= nextn) {
                 int sc;
                 if (finishing) {        // å·²ç»å®Œæˆè½¬ç§»
                     nextTable = null;
                     table = nextTab;
                     sizeCtl = (n << 1) - (n >>> 1);    // è®¾ç½®sizeCtlä¸ºæ‰©å®¹åçš„0.75
                     return;
                 }
                 if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {
                     if ((sc - 2) != resizeStamp(n) << RESIZE_STAMP_SHIFT) {
                         return;
                     }
                     finishing = advance = true;
                     i = n; // recheck before commit
                 }
             }
             else if ((f = tabAt(tab, i)) == null)         // æ•°ç»„ä¸­æŠŠnullçš„å…ƒç´ è®¾ç½®ä¸ºForwardingNodeèŠ‚ç‚¹(hashå€¼ä¸ºMOVED[-1])
                 advance = casTabAt(tab, i, null, fwd);
             else if ((fh = f.hash) == MOVED)
                 advance = true; // already processed
             else {
                 synchronized (f) {                // åŠ é”æ“ä½œ
                     if (tabAt(tab, i) == f) {
                         Node<K,V> ln, hn;
                         if (fh >= 0) {        // è¯¥èŠ‚ç‚¹çš„hashå€¼å¤§äºç­‰äº0ï¼Œè¯´æ˜æ˜¯ä¸€ä¸ªNodeèŠ‚ç‚¹
                             /*
                              *  å› ä¸ºnçš„å€¼ä¸ºæ•°ç»„çš„é•¿åº¦ï¼Œä¸”æ˜¯power(2,x)çš„ï¼Œæ‰€ä»¥ï¼Œåœ¨&æ“ä½œçš„ç»“æœåªå¯èƒ½æ˜¯0æˆ–è€…n
                              *  æ ¹æ®è¿™ä¸ªè§„åˆ™
                              *         0-->  æ”¾åœ¨æ–°è¡¨çš„ç›¸åŒä½ç½®
                              *         n-->  æ”¾åœ¨æ–°è¡¨çš„ï¼ˆn+åŸæ¥ä½ç½®ï¼‰
                              */
                             int runBit = fh & n; 
                             Node<K,V> lastRun = f;
                             /*
                              *  lastRun è¡¨ç¤ºçš„æ˜¯éœ€è¦å¤åˆ¶çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹
                              *  æ¯å½“æ–°èŠ‚ç‚¹çš„hash&n -> b å‘ç”Ÿå˜åŒ–çš„æ—¶å€™ï¼Œå°±æŠŠrunBitè®¾ç½®ä¸ºè¿™ä¸ªç»“æœb
                              *  è¿™æ ·forå¾ªç¯ä¹‹åï¼ŒrunBitçš„å€¼å°±æ˜¯æœ€åä¸å˜çš„hash&nçš„å€¼
                              *  è€ŒlastRunçš„å€¼å°±æ˜¯æœ€åä¸€æ¬¡å¯¼è‡´hash&n å‘ç”Ÿå˜åŒ–çš„èŠ‚ç‚¹(å‡è®¾ä¸ºpèŠ‚ç‚¹)
                              *  ä¸ºä»€ä¹ˆè¦è¿™ä¹ˆåšå‘¢ï¼Ÿå› ä¸ºpèŠ‚ç‚¹åé¢çš„èŠ‚ç‚¹çš„hash&n å€¼è·ŸpèŠ‚ç‚¹æ˜¯ä¸€æ ·çš„ï¼Œ
                              *  æ‰€ä»¥åœ¨å¤åˆ¶åˆ°æ–°çš„tableçš„æ—¶å€™ï¼Œå®ƒè‚¯å®šè¿˜æ˜¯è·ŸpèŠ‚ç‚¹åœ¨åŒä¸€ä¸ªä½ç½®
                              *  åœ¨å¤åˆ¶å®ŒpèŠ‚ç‚¹ä¹‹åï¼ŒpèŠ‚ç‚¹çš„nextèŠ‚ç‚¹è¿˜æ˜¯æŒ‡å‘å®ƒåŸæ¥çš„èŠ‚ç‚¹ï¼Œå°±ä¸éœ€è¦è¿›è¡Œå¤åˆ¶äº†ï¼Œè‡ªå·±å°±è¢«å¸¦è¿‡å»äº†
                              *  è¿™ä¹Ÿå°±å¯¼è‡´äº†ä¸€ä¸ªé—®é¢˜å°±æ˜¯å¤åˆ¶åçš„é“¾è¡¨çš„é¡ºåºå¹¶ä¸ä¸€å®šæ˜¯åŸæ¥çš„å€’åº
                              */
                             for (Node<K,V> p = f.next; p != null; p = p.next) {
                                 int b = p.hash & n;    // nçš„å€¼ä¸ºæ‰©å¼ å‰çš„æ•°ç»„çš„é•¿åº¦
                                 if (b != runBit) {
                                     runBit = b;
                                     lastRun = p;
                                 }
                             }
                             if (runBit == 0) {
                                 ln = lastRun;
                                 hn = null;
                             }
                             else {
                                 hn = lastRun;
                                 ln = null;
                             }
                             /*
                              *  æ„é€ ä¸¤ä¸ªé“¾è¡¨ï¼Œé¡ºåºå¤§éƒ¨åˆ†å’ŒåŸæ¥æ˜¯åçš„
                              *  åˆ†åˆ«æ”¾åˆ°åŸæ¥çš„ä½ç½®å’Œæ–°å¢åŠ çš„é•¿åº¦çš„ç›¸åŒä½ç½®(i/n+i)
                              */
                             for (Node<K,V> p = f; p != lastRun; p = p.next) {
                                 int ph = p.hash; K pk = p.key; V pv = p.val;
                                 if ((ph & n) == 0)
                                     /*
                                      *  å‡è®¾runBitçš„å€¼ä¸º0ï¼Œ
                                      *  åˆ™ç¬¬ä¸€æ¬¡è¿›å…¥è¿™ä¸ªè®¾ç½®çš„æ—¶å€™ç›¸å½“äºæŠŠæ—§çš„åºåˆ—çš„æœ€åä¸€æ¬¡å‘ç”Ÿhashå˜åŒ–çš„èŠ‚ç‚¹(è¯¥èŠ‚ç‚¹åé¢å¯èƒ½è¿˜æœ‰hashè®¡ç®—ååŒä¸º0çš„èŠ‚ç‚¹)è®¾ç½®åˆ°æ—§çš„tableçš„ç¬¬ä¸€ä¸ªhashè®¡ç®—åä¸º0çš„èŠ‚ç‚¹ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
                                      *  å¹¶ä¸”æŠŠè‡ªå·±è¿”å›ï¼Œç„¶ååœ¨ä¸‹æ¬¡è¿›æ¥çš„æ—¶å€™æŠŠå®ƒè‡ªå·±è®¾ç½®ä¸ºåé¢èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
                                      */
                                     ln = new Node<K,V>(ph, pk, pv, ln);
                                 else
                                     /*
                                      *  å‡è®¾runBitçš„å€¼ä¸ä¸º0ï¼Œ
                                      *  åˆ™ç¬¬ä¸€æ¬¡è¿›å…¥è¿™ä¸ªè®¾ç½®çš„æ—¶å€™ç›¸å½“äºæŠŠæ—§çš„åºåˆ—çš„æœ€åä¸€æ¬¡å‘ç”Ÿhashå˜åŒ–çš„èŠ‚ç‚¹(è¯¥èŠ‚ç‚¹åé¢å¯èƒ½è¿˜æœ‰hashè®¡ç®—ååŒä¸ä¸º0çš„èŠ‚ç‚¹)è®¾ç½®åˆ°æ—§çš„tableçš„ç¬¬ä¸€ä¸ªhashè®¡ç®—åä¸ä¸º0çš„èŠ‚ç‚¹ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
                                      *  å¹¶ä¸”æŠŠè‡ªå·±è¿”å›ï¼Œç„¶ååœ¨ä¸‹æ¬¡è¿›æ¥çš„æ—¶å€™æŠŠå®ƒè‡ªå·±è®¾ç½®ä¸ºåé¢èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
                                      */
                                     hn = new Node<K,V>(ph, pk, pv, hn);    
                             }
                             setTabAt(nextTab, i, ln);    
                             setTabAt(nextTab, i + n, hn);
                             setTabAt(tab, i, fwd);
                             advance = true;
                         }
                         else if (f instanceof TreeBin) {    // å¦åˆ™çš„è¯æ˜¯ä¸€ä¸ªæ ‘èŠ‚ç‚¹
                             TreeBin<K,V> t = (TreeBin<K,V>)f;
                             TreeNode<K,V> lo = null, loTail = null;
                             TreeNode<K,V> hi = null, hiTail = null;
                             int lc = 0, hc = 0;
                             for (Node<K,V> e = t.first; e != null; e = e.next) {
                                 int h = e.hash;
                                 TreeNode<K,V> p = new TreeNode<K,V>
                                     (h, e.key, e.val, null, null);
                                 if ((h & n) == 0) {
                                     if ((p.prev = loTail) == null)
                                         lo = p;
                                     else
                                         loTail.next = p;
                                     loTail = p;
                                     ++lc;
                                 }
                                 else {
                                     if ((p.prev = hiTail) == null)
                                         hi = p;
                                     else
                                         hiTail.next = p;
                                     hiTail = p;
                                     ++hc;
                                 }
                             }
                             /*
                              *  åœ¨å¤åˆ¶å®Œæ ‘èŠ‚ç‚¹ä¹‹åï¼Œåˆ¤æ–­è¯¥èŠ‚ç‚¹å¤„æ„æˆçš„æ ‘è¿˜æœ‰å‡ ä¸ªèŠ‚ç‚¹ï¼Œ
                              *  å¦‚æœâ‰¤6ä¸ªçš„è¯ï¼Œå°±è½¬å›ä¸ºä¸€ä¸ªé“¾è¡¨
                              */
                             ln = (lc <= UNTREEIFY_THRESHOLD) ? untreeify(lo) :
                             (hc != 0) ? new TreeBin<K,V>(lo) : t;
                             hn = (hc <= UNTREEIFY_THRESHOLD) ? untreeify(hi) :
                             (lc != 0) ? new TreeBin<K,V>(hi) : t;
                             setTabAt(nextTab, i, ln);
                             setTabAt(nextTab, i + n, hn);
                             setTabAt(tab, i, fwd);
                             advance = true;
                         }
                     }
                 }
             }
         }
     }
     ```

     **åˆ°è¿™é‡Œï¼Œ`ConcurrentHashMap` çš„ `putæ“ä½œ` å’Œ`æ‰©å®¹æ“ä½œ` åŸºæœ¬ä¸Šä»‹ç»å®Œæ¯•ã€‚**

 2. get æ–¹æ³•

     ```java
     /*
      *  ç›¸æ¯”putæ–¹æ³•ï¼Œgetå°±å¾ˆå•çº¯äº†ï¼Œæ”¯æŒå¹¶å‘æ“ä½œï¼Œ
      *  å½“keyä¸ºnullçš„æ—¶å€™å›æŠ›å‡ºNullPointerExceptionçš„å¼‚å¸¸
      *  getæ“ä½œé€šè¿‡é¦–å…ˆè®¡ç®—keyçš„hashå€¼æ¥ç¡®å®šè¯¥å…ƒç´ æ”¾åœ¨æ•°ç»„çš„å“ªä¸ªä½ç½®
      *  ç„¶åéå†è¯¥ä½ç½®çš„æ‰€æœ‰èŠ‚ç‚¹
      *  å¦‚æœä¸å­˜åœ¨çš„è¯è¿”å›null
      */
     public V get(Object key) {
         Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;
         int h = spread(key.hashCode());
         if ((tab = table) != null && (n = tab.length) > 0 &&
             (e = tabAt(tab, (n - 1) & h)) != null) {
             if ((eh = e.hash) == h) { // å“ˆå¸Œå€¼ç›¸ç­‰
                 if ((ek = e.key) == key || (ek != null && key.equals(ek))) // keyç›¸ç­‰
                     return e.val; // åˆ™è¿”å›
             }
             else if (eh < 0)
                 return (p = e.find(h, key)) != null ? p.val : null;
             while ((e = e.next) != null) {
                 if (e.hash == h &&
                     ((ek = e.key) == key || (ek != null && key.equals(ek))))
                     return e.val;
             }
         }
         return null;
     }
     ```

     > å…¶ä»–æ“ä½œæ–¹æ³•åŸºæœ¬ä¸Šä¸ HashMap ç±»ä¼¼ï¼Œè¿™é‡Œå°±ä¸åšè¯¦ç»†ä»‹ç»äº†ã€‚

- åŒæ­¥æœºåˆ¶

  **ConcurrentHashMap** æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œé‚£ä¹ˆå®ƒæ˜¯å¦‚ä½•åšåˆ°å¹¶å‘æƒ…å†µä¸‹ï¼Œå¦‚ä½•åšåˆ°åŒæ­¥çš„å‘¢? æ¥ä¸‹æ¥ï¼Œè®©æˆ‘ä¸€æ­¥æ­¥æ¥å‰–æä¸‹å…¶æ˜¯å¦‚ä½•å®ç°çš„.

  > è¯»æ“ä½œ

  è¯»æ“ä½œå³ï¼ˆget æ“ä½œï¼‰ï¼Œæ ¹æ®ä¸Šè¿°æºç è§£æï¼Œæ²¡æœ‰ä½¿ç”¨åŒæ­¥æœºåˆ¶ ï¼Œä¹Ÿæ²¡æœ‰ä½¿ç”¨unsafeæ–¹æ³•ï¼Œæ‰€ä»¥è¯»æ“ä½œæ˜¯æ”¯æŒå¹¶å‘æ“ä½œçš„ã€‚

  > å†™æ“ä½œ

  å†™æ“ä½œå³ï¼ˆput æ“ä½œ ï¼‰ï¼Œæ ¹æ®ä¸Šé¢æºç å‰–æï¼Œæˆ‘ä»¬çŸ¥é“æ‰©å®¹æœ€ç»ˆæ˜¯é€šè¿‡ `transfer` æ–¹æ³•è¿›è¡Œçš„ ï¼Œè€Œè°ƒç”¨transferæ–¹æ³•çš„åªæœ‰`trePresize` ã€`helpTransfer` å’Œ `addCount` ä¸‰ä¸ªæ–¹æ³•ã€‚

  * tryPresizeæ˜¯åœ¨treeIfybinå’ŒputAllæ–¹æ³•ä¸­è°ƒç”¨ï¼ŒtreeIfybinä¸»è¦æ˜¯åœ¨putæ·»åŠ å…ƒç´ å®Œä¹‹åï¼Œåˆ¤æ–­è¯¥æ•°ç»„èŠ‚ç‚¹ç›¸å…³å…ƒç´ æ˜¯ä¸æ˜¯å·²ç»è¶…è¿‡8ä¸ªçš„æ—¶å€™ï¼Œå¦‚æœè¶…è¿‡åˆ™ä¼šè°ƒç”¨è¿™ä¸ªæ–¹æ³•æ¥æ‰©å®¹æ•°ç»„æˆ–è€…æŠŠé“¾è¡¨è½¬ä¸ºæ ‘ã€‚
  * helpTransferæ˜¯åœ¨å½“ä¸€ä¸ªçº¿ç¨‹è¦å¯¹tableä¸­å…ƒç´ è¿›è¡Œæ“ä½œçš„æ—¶å€™ï¼Œå¦‚æœæ£€æµ‹åˆ°èŠ‚ç‚¹çš„HASHå€¼ä¸ºMOVEDçš„æ—¶å€™ï¼Œå°±ä¼šè°ƒç”¨helpTransferæ–¹æ³•ï¼Œåœ¨helpTransferä¸­å†è°ƒç”¨transferæ–¹æ³•æ¥å¸®åŠ©å®Œæˆæ•°ç»„çš„æ‰©å®¹ã€‚
  * addCountæ˜¯åœ¨å½“å¯¹æ•°ç»„è¿›è¡Œæ“ä½œï¼Œä½¿å¾—æ•°ç»„ä¸­å­˜å‚¨çš„å…ƒç´ ä¸ªæ•°å‘ç”Ÿäº†å˜åŒ–çš„æ—¶å€™ä¼šè°ƒç”¨çš„æ–¹æ³•ã€‚

  **å¼•èµ·æ•°ç»„æ‰©å®¹çš„æƒ…å†µï¼Ÿ**

     - åªæœ‰åœ¨å¾€mapä¸­æ·»åŠ å…ƒç´ çš„æ—¶å€™ï¼Œåœ¨æŸä¸€ä¸ªèŠ‚ç‚¹çš„æ•°ç›®å·²ç»è¶…è¿‡äº†8ä¸ªï¼ŒåŒæ—¶æ•°ç»„çš„é•¿åº¦åˆå°äº64çš„æ—¶å€™ï¼Œæ‰ä¼šè§¦å‘æ•°ç»„çš„æ‰©å®¹
     - å½“æ•°ç»„ä¸­å…ƒç´ è¾¾åˆ°äº†sizeCtlçš„æ•°é‡çš„æ—¶å€™ï¼Œåˆ™ä¼šè°ƒç”¨transferæ–¹æ³•æ¥è¿›è¡Œæ‰©å®¹

  **åœ¨æ‰©å®¹çš„æ—¶å€™ï¼Œå¯ä»¥ä¸å¯ä»¥å¯¹æ•°ç»„è¿›è¡Œè¯»å†™æ“ä½œå‘¢ï¼Ÿ**

     äº‹å®ä¸Šæ˜¯å¯ä»¥çš„ã€‚
     - å½“æ‰©å®¹æ—¶ï¼Œå¦‚æœå½“å‰èŠ‚ç‚¹è¿˜æ²¡æœ‰è¢«å¤„ç†ï¼ˆä¹Ÿå°±æ˜¯è¯´è¿˜æ²¡æœ‰è®¾ç½®ä¸ºfwdèŠ‚ç‚¹ï¼‰ï¼Œé‚£å°±å¯ä»¥è¿›è¡Œè®¾ç½®æ“ä½œã€‚
     - å½“æ‰©å®¹æ—¶ï¼Œå¦‚æœè¯¥èŠ‚ç‚¹å·²ç»è¢«å¤„ç†äº†ï¼Œåˆ™å½“å‰çº¿ç¨‹ä¹Ÿä¼šåŠ å…¥åˆ°æ‰©å®¹çš„æ“ä½œä¸­å»ã€‚

  **å¤šçº¿ç¨‹åˆæ˜¯å¦‚ä½•åŒæ­¥å¤„ç†çš„å‘¢ï¼Ÿ**

     åœ¨`ConcurrentHashMap`ä¸­ï¼ŒåŒæ­¥å¤„ç†ä¸»è¦æ˜¯é€šè¿‡ `Synchronized` å’Œ `unsafe` ä¸¤ç§æ–¹å¼æ¥å®Œæˆçš„ã€‚

     - åœ¨å–å¾—sizeCtlã€æŸä¸ªä½ç½®çš„Nodeçš„æ—¶å€™ï¼Œä½¿ç”¨çš„éƒ½æ˜¯unsafeçš„æ–¹æ³•ï¼Œæ¥è¾¾åˆ°å¹¶å‘å®‰å…¨çš„ç›®çš„ã€‚
     - å½“éœ€è¦åœ¨æŸä¸ªä½ç½®è®¾ç½®èŠ‚ç‚¹çš„æ—¶å€™ï¼Œåˆ™ä¼šé€šè¿‡Synchronizedçš„åŒæ­¥æœºåˆ¶æ¥é”å®šè¯¥ä½ç½®çš„èŠ‚ç‚¹ã€‚
     - åœ¨æ•°ç»„æ‰©å®¹çš„æ—¶å€™ï¼Œåˆ™é€šè¿‡å¤„ç†çš„æ­¥é•¿å’ŒfwdèŠ‚ç‚¹æ¥è¾¾åˆ°å¹¶å‘å®‰å…¨çš„ç›®çš„ï¼Œé€šè¿‡è®¾ç½®hashå€¼ä¸ºMOVEDã€‚
     - å½“æŠŠæŸä¸ªä½ç½®çš„èŠ‚ç‚¹å¤åˆ¶åˆ°æ‰©å¼ åçš„tableçš„æ—¶å€™ï¼Œä¹Ÿé€šè¿‡Synchronizedçš„åŒæ­¥æœºåˆ¶æ¥ä¿è¯ç°ç¨‹å®‰å…¨ã€‚

**ç»¼ä¸Šæ‰€è¿°ï¼Œ`ConcurrentHashMap` åŸºæœ¬ä¸Šä»‹ç»å®Œæ¯•ï¼Œå¸Œæœ›å¯¹å¤§å®¶æœ‰æ‰€å¸®åŠ©ï¼ï¼ï¼**

------
> æ–‡ç« å¯ä»¥ç™½å«–ï¼Œè€é“ä»¬é¡ºä¾¿å…³æ³¨ä¸€ä¸‹æˆ‘çš„å…¬ä¼—å·ï¼Œæ‰‹åŠ¨æ»‘ç¨½ğŸ¤£ğŸ¤£ &nbsp;
>
> æ¬¢è¿å¤§å®¶å…³æ³¨ï¼š**æ­¦å“¥èŠç¼–ç¨‹**ã€**Javaå¼€å‘å®å…¸**ã€**Javaç§ƒå¤´å“¥**ï¼Œæ‚¨çš„æ”¯æŒï¼Œæ˜¯æˆ‘åˆ›ä½œçš„æŒç»­åŠ¨åŠ›ï¼&nbsp;&nbsp;

![å…¬ä¼—å·äºŒç»´ç ](https://img-blog.csdnimg.cn/20201121225359995.png)