> æ–‡ç« å¯ä»¥ç™½å«–ï¼Œè€é“ä»¬é¡ºä¾¿å…³æ³¨ä¸€ä¸‹æˆ‘çš„å…¬ä¼—å·ï¼Œæ‰‹åŠ¨æ»‘ç¨½ğŸ¤£ğŸ¤£ &nbsp;
>
> æ¬¢è¿å¤§å®¶å…³æ³¨ï¼š**æ­¦å“¥èŠç¼–ç¨‹**ã€**Javaå¼€å‘å®å…¸**ã€**Javaç§ƒå¤´å“¥**ï¼Œæ‚¨çš„æ”¯æŒï¼Œæ˜¯æˆ‘åˆ›ä½œçš„æŒç»­åŠ¨åŠ›ï¼&nbsp;&nbsp;

![å…¬ä¼—å·äºŒç»´ç ](https://img-blog.csdnimg.cn/20201121225359995.png)

----

## HashTable ç®€ä»‹

`Hashtable` æ˜¯ä¸€ä¸ªæ•£åˆ—è¡¨ï¼Œå®ƒå­˜å‚¨çš„å†…å®¹æ˜¯ `é”®å€¼å¯¹(key-value)æ˜ å°„`ã€‚

```
# hashtable å£°æ˜
public class Hashtable<K,V>
    extends Dictionary<K,V>
    implements Map<K,V>, Cloneable, java.io.Serializable {
    
    ......
    
}
```

- Hashtableç»§æ‰¿äºDictionaryæŠ½è±¡ç±»ï¼ŒDictionaryä¸­å®šä¹‰äº†å¯¹äºå®¹å™¨æ“ä½œçš„å¤šç§æŠ½è±¡æ–¹æ³•ã€‚
- å®ç°Mapæ¥å£ï¼ŒHashtableå®ç°äº†Mapæ¥å£ä¸­å®šä¹‰çš„æ–¹æ³•ã€‚
- å®ç°Cloneableæ¥å£ã€‚
- å®ç°Serializableæ¥å£ï¼Œå¯åºåˆ—åŒ–ã€‚

## æ•°æ®ç»“æ„

```
/**
 *  é”®å€¼å¯¹/Entryæ•°ç»„ï¼Œæ¯ä¸ªEntryæœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªå•å‘é“¾è¡¨çš„è¡¨å¤´
 */
private transient Entry<?,?>[] table;

/**
 *  1. å†…éƒ¨é™æ€ç±»Entryï¼ŒEntryä¸ºå­˜å‚¨çš„èŠ‚ç‚¹
 *  2. Entryæœ¬è´¨ä¸ºé“¾è¡¨
 */
private static class Entry<K,V> implements Map.Entry<K,V> {
    // å“ˆå¸Œå€¼
    final int hash;
    // é”®
    final K key;
    // å€¼
    V value;
    // æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
    Entry<K,V> next;
    
    // æ„é€ æ–¹æ³•
    protected Entry(int hash, K key, V value, Entry<K,V> next) {
        this.hash = hash;
        this.key =  key;
        this.value = value;
        this.next = next;
    }
    
    // å…‹éš†æ“ä½œ
    @SuppressWarnings("unchecked")
    protected Object clone() {
        return new Entry<>(hash, key, value,
                              (next==null ? null : (Entry<K,V>) next.clone()));
    }

    // Map.Entry Ops
    
    // è·å– key
    public K getKey() {
        return key;
    }
    
    // è·å– value
    public V getValue() {
        return value;
    }
    
    // è®¾ç½® value
    public V setValue(V value) {
        if (value == null)   /**  ç”±æ­¤å¯çŸ¥ï¼Œhashtable valueä¸å¯èƒ½ä¸ºnull  **/
            throw new NullPointerException();

        V oldValue = this.value;
        this.value = value;
        return oldValue;
    }
    
    // åˆ¤æ–­ä¸¤ä¸ª Entryæ˜¯å¦ç›¸ç­‰
    public boolean equals(Object o) {
        if (!(o instanceof Map.Entry))
            return false;
        Map.Entry<?,?> e = (Map.Entry<?,?>)o;
        /**  ç”±æ­¤å¯çŸ¥ï¼Œkeyä¸valueéƒ½ç›¸ç­‰æ‰ç®—ç›¸ç­‰   **/
        return (key==null ? e.getKey()==null : key.equals(e.getKey())) &&
           (value==null ? e.getValue()==null : value.equals(e.getValue()));
    }
    
    // è®¡ç®— hashcode
    public int hashCode() {
        return hash ^ Objects.hashCode(value);
    }
    
    // é‡å†™ toString æ–¹æ³•
    public String toString() {
        return key.toString()+"="+value.toString();
    }
}
```
> ç”±ä¸Šå¯çŸ¥

- HashTable å°±æ˜¯ `ä¸€ä¸ªå­˜å‚¨Entryçš„æ•°ç»„`
- Entryä¸­åŒ…å« `å­˜å‚¨çš„é”®å€¼å¯¹` ä»¥åŠ `ä¸‹ä¸€ä¸ªèŠ‚ç‚¹`
- Entryä¸­ `value` æ˜¯ `ä¸å¯ä¸ºç©ºçš„`

## æºç åˆ†æ

* æˆå‘˜å±æ€§

```
/**
 *  1. ä¿å­˜ k-v çš„æ•°ç»„,æ”¯æŒæ³›å‹ 
 *  2. Entry é‡‡ç”¨é“¾è¡¨è§£å†³å†²çªï¼Œæœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªå•å‘é“¾è¡¨
 */
private transient Entry<?,?>[] table;

/**
 *  Entryä¸­é”®å€¼å¯¹çš„æ•°é‡
 */
private transient int count;

/**
 *  é˜ˆå€¼ï¼Œç”¨äºåˆ¤æ–­æ˜¯å¦éœ€è¦è°ƒæ•´ Entry çš„å®¹é‡ï¼ˆthreshold = å®¹é‡*åŠ è½½å› å­ï¼‰
 */
private int threshold;

/**
 *  è´Ÿè½½å› å­ï¼Œå½“å…ƒç´ ä¸ªæ•° count å¤§äºæ€»å®¹é‡ * è´Ÿè½½å› å­æ—¶ï¼Œæ‰©å®¹
 */
private float loadFactor;

/**
 *  Entry è¢«æ”¹å˜çš„æ¬¡æ•°ï¼Œç”¨äºfail-fastæœºåˆ¶çš„å®ç°
 */
private transient int modCount = 0;
```

* æ„é€ æ–¹æ³•

```
/**
 *  å¸¦æœ‰åˆå§‹åŒ–å®¹é‡å¤§å°å’Œè´Ÿè½½å› å­çš„æ„é€ æ–¹æ³•.
 */
public Hashtable(int initialCapacity, float loadFactor) {
    if (initialCapacity < 0)
        throw new IllegalArgumentException("Illegal Capacity: "+
                                           initialCapacity);
    if (loadFactor <= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException("Illegal Load: "+loadFactor);

    if (initialCapacity==0)
        initialCapacity = 1;
    this.loadFactor = loadFactor;
    table = new Entry<?,?>[initialCapacity];
    threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1);
}

/**
 *  å¸¦æœ‰åˆå§‹åŒ–å®¹é‡å¤§å°çš„æ„é€ æ–¹æ³•
 */
public Hashtable(int initialCapacity) {
    // æ³¨æ„ï¼šé»˜è®¤è´Ÿè½½å› å­è®¾ç½®ä¸º 0.75
    this(initialCapacity, 0.75f);
}

/**
 *  é»˜è®¤æ— å‚æ„é€ æ–¹æ³•
 */
public Hashtable() {
   // é»˜è®¤å®¹é‡å¤§å°ä¸º 11ï¼Œè´Ÿè½½å› å­è®¾ç½®ä¸º 0.75
    this(11, 0.75f);
}

/**
 *  ä½¿ç”¨Mapé›†åˆåˆå§‹åŒ–æ„é€ æ–¹æ³•
 */
public Hashtable(Map<? extends K, ? extends V> t) {
    // è‹¥é›†åˆtå…ƒç´ å¤§äº 5ï¼Œåˆ™åˆå§‹åŒ–å®¹é‡ä¸ºé›†åˆ t ä¸­å…ƒç´ æ•°ç›®çš„ 2å€ï¼Œå¦åˆ™åˆå§‹åŒ–å®¹é‡ä¸º 11
    // è´Ÿè½½å› å­è®¾ç½®ä¸º 0.75
    this(Math.max(2*t.size(), 11), 0.75f);
    //å°†é›†åˆtä¸­å…ƒç´ å…¨éƒ¨å­˜å‚¨
    putAll(t);
}
```
**ç”±æ­¤å¯çŸ¥ï¼Œæˆ‘ä»¬ä¸æŒ‡å®šæ•°ç»„å®¹é‡å’ŒåŠ è½½å› å­ï¼ŒHashTable é»˜è®¤åˆå§‹åŒ–å®¹é‡ä¸º `11`ï¼Œé»˜è®¤è´Ÿè½½å› å­ä¸º `0.75`ï¼ˆ***ä¸HashMapæ˜¯ç›¸åŒçš„***ï¼‰ã€‚**

* å­˜å–æ–¹æ³•

1. put æ–¹æ³•

```
/**
 *  put æ“ä½œ
 */
public synchronized V put(K key, V value) {
    // æ£€éªŒæ•°æ®å€¼çš„åˆæ³•æ€§,ç¡®ä¿ valueå€¼ä¸èƒ½ä¸ºç©º
    if (value == null) {
        throw new NullPointerException();
    }
    
    Entry<?,?> tab[] = table;
    // æ ¹æ®é”®å€¼è·å–ç´¢å¼•index
    int hash = key.hashCode();
    // æ ¹æ®å“ˆå¸Œå€¼è®¡ç®—åœ¨æ•°ç»„ä¸­çš„ç´¢å¼•
    int index = (hash & 0x7FFFFFFF) % tab.length;
    @SuppressWarnings("unchecked")
    Entry<K,V> entry = (Entry<K,V>)tab[index];
    for(; entry != null ; entry = entry.next) {
        if ((entry.hash == hash) && entry.key.equals(key)) {  // è‹¥ keyå·²å­˜åœ¨
            V old = entry.value;
            // åˆ™è¦†ç›–æ‰åŸæ¥çš„å€¼
            entry.value = value;
            return old; // å¹¶è¿”å›åŸæ¥çš„å€¼
        }
    }
    
    // è‹¥ keyä¸å­˜åœ¨ï¼Œåˆ™å°† key å’Œ value æ·»åŠ é“¾è¡¨æœ«å°¾
    addEntry(hash, key, value, index);
    return null;
}

/**
 *  å¢åŠ  entry
 */
private void addEntry(int hash, K key, V value, int index) {
    modCount++;

    Entry<?,?> tab[] = table;
    // åˆ¤æ–­å½“å‰æ•°ç›®æ˜¯å¦è¶…è¿‡é˜ˆå€¼
    if (count >= threshold) {
        // è¶…è¿‡é˜ˆå€¼è¿›è¡Œæ‰©å®¹
        rehash();
        
        // æ›´æ–°æ‰©å®¹åçš„æ•°ç»„ä¿¡æ¯
        tab = table;
        hash = key.hashCode();
        index = (hash & 0x7FFFFFFF) % tab.length;
    }

    // æ²¡æœ‰è¶…è¿‡é˜ˆå€¼ï¼Œåˆ™æ–°å¢ entry æ·»åŠ åˆ°æ•°ç»„ä¸­
    @SuppressWarnings("unchecked")
    Entry<K,V> e = (Entry<K,V>) tab[index];
    tab[index] = new Entry<>(hash, key, value, e);
    
    // åŒæ—¶å…ƒç´ æ€»æ•°é‡å¾—åŠ  1
    count++;
}

/**
 *  æ‰©å®¹
 */
protected void rehash() {
    // è·å–æ—§æ•°ç»„å¤§å°
    int oldCapacity = table.length;
    Entry<?,?>[] oldMap = table;

    // åˆ›å»ºæ–°å®¹é‡å¤§å°çš„ Entry æ•°ç»„ï¼Œæ•°ç»„å®¹é‡å¤§å°ä¸ºåŸæ•°ç»„çš„ 2 å€ + 1
    int newCapacity = (oldCapacity << 1) + 1;
    // ä¸èƒ½è¶…å‡ºæœ€å¤§å€¼
    if (newCapacity - MAX_ARRAY_SIZE > 0) { 
        if (oldCapacity == MAX_ARRAY_SIZE)
            return;
        newCapacity = MAX_ARRAY_SIZE;
    }
    Entry<?,?>[] newMap = new Entry<?,?>[newCapacity];

    modCount++;
    
    // é‡æ–°è®¡ç®—é˜ˆå€¼
    threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1);
    table = newMap;

   // å°†åŸæ•°ç»„ä¸­å…ƒç´ æ‹·è´è‡³æ–°æ•°ç»„
    for (int i = oldCapacity ; i-- > 0 ;) {
        for (Entry<K,V> old = (Entry<K,V>)oldMap[i] ; old != null ; ) {
            Entry<K,V> e = old;
            old = old.next;

            int index = (e.hash & 0x7FFFFFFF) % newCapacity;
            e.next = (Entry<K,V>)newMap[index];
            newMap[index] = e;
        }
    }
}
```

2. get æ–¹æ³•

```
/**
 *  è·å– value
 */
public synchronized V get(Object key) {
    Entry<?,?> tab[] = table;
    // è·å– keyçš„å“ˆå¸Œå€¼
    int hash = key.hashCode();
    // æ ¹æ®å“ˆå¸Œå€¼è®¡ç®—ç´¢å¼•å€¼
    int index = (hash & 0x7FFFFFFF) % tab.length;
    // æ ¹æ®indexæ‰¾åˆ°keyå¯¹åº”Entryé“¾è¡¨ï¼Œéå†é“¾è¡¨æ‰¾åˆ°å“ˆå¸Œå€¼ä¸é”®å€¼å‡ä¸keyç›¸åŒçš„å…ƒç´ 
    for (Entry<?,?> e = tab[index] ; e != null ; e = e.next) {
        if ((e.hash == hash) && e.key.equals(key)) {
            return (V)e.value;
        }
    }
    
    // æ‰¾ä¸åˆ°ï¼Œåˆ™è¿”å›null
    return null;
}
```

3. å…¶ä»–å¸¸ç”¨æ–¹æ³•

```
/** -----------åŒ…å«ç›¸å…³æ–¹æ³•----------- */

// åˆ¤æ–­æ˜¯å¦å«æœ‰ value
public boolean containsValue(Object value) {
    return contains(value);
}

public synchronized boolean contains(Object value) {

    // æ£€æŸ¥å‚æ•°çš„åˆæ³•æ€§
    if (value == null) {
        throw new NullPointerException();
    }

    // åŒé‡forå¾ªç¯ï¼Œå¤–å¾ªç¯éå†æ•°ç»„ï¼Œå†…å¾ªç¯éå†é“¾è¡¨
    Entry<?,?> tab[] = table;
    for (int i = tab.length ; i-- > 0 ;) {
        for (Entry<?,?> e = tab[i] ; e != null ; e = e.next) {
            if (e.value.equals(value)) {
                return true;
            }
        }
    }
    return false;
}

// åˆ¤æ–­æ˜¯å¦åŒ…å«é”®å€¼ key
public synchronized boolean containsKey(Object key) {
    Entry<?,?> tab[] = table;
    int hash = key.hashCode();
    int index = (hash & 0x7FFFFFFF) % tab.length;
    // indexå®šä½æ•°ç»„ä½ç½®ï¼Œforéå†é“¾è¡¨æŸ¥æ‰¾å…ƒç´ 
    for (Entry<?,?> e = tab[index] ; e != null ; e = e.next) {
        if ((e.hash == hash) && e.key.equals(key)) {
            return true;
        }
    }
    return false;
}

/** -----------æ›¿æ¢æ–¹æ³•----------- */

// æ›¿æ¢æŒ‡å®š key çš„å€¼
public synchronized V replace(K key, V value) {
    Objects.requireNonNull(value);
    // æ ¹æ®é”®å€¼æŸ¥æ‰¾å…ƒç´ 
    Entry<?,?> tab[] = table;
    int hash = key.hashCode();
    int index = (hash & 0x7FFFFFFF) % tab.length;
    @SuppressWarnings("unchecked")
    Entry<K,V> e = (Entry<K,V>)tab[index];
    for (; e != null; e = e.next) {
         // æŸ¥æ‰¾æˆåŠŸï¼Œæ›¿æ¢å…ƒç´ å€¼
        if ((e.hash == hash) && e.key.equals(key)) {
            V oldValue = e.value;
            e.value = value;
            return oldValue;
        }
    }
    return null;
}

/** -----------ç§»é™¤æ–¹æ³•----------- */

// æ ¹æ®é”®å€¼åˆ é™¤å…ƒç´ ï¼Œè¿”å›è¢«åˆ é™¤å…ƒç´ å€¼
public synchronized V remove(Object key) {
    Entry<?,?> tab[] = table;
    int hash = key.hashCode();
    int index = (hash & 0x7FFFFFFF) % tab.length;
    @SuppressWarnings("unchecked")
    Entry<K,V> e = (Entry<K,V>)tab[index];
     // foréå†é“¾è¡¨æŸ¥æ‰¾å…ƒç´ 
    for(Entry<K,V> prev = null ; e != null ; prev = e, e = e.next) {
        // æŸ¥æ‰¾åˆ°å…ƒç´ è¿›è¡Œé“¾è¡¨çš„èŠ‚ç‚¹åˆ é™¤æ“ä½œ
        if ((e.hash == hash) && e.key.equals(key)) {
            modCount++;
            if (prev != null) {
                prev.next = e.next;
            } else {
                tab[index] = e.next;
            }
            count--;
            V oldValue = e.value;
            // æ¸…ç©ºå€¼
            e.value = null;
            // è¿”å›å€¼
            return oldValue;
        }
    }
    return null;
}

/** -----------elements()æ–¹æ³•----------- */

public synchronized Enumeration<V> elements() {
    return this.<V>getEnumeration(VALUES);
}
 
// è·å–Hashtableçš„æšä¸¾ç±»å¯¹è±¡    
// è‹¥Hashtableçš„å®é™…å¤§å°ä¸º0,åˆ™è¿”å›â€œç©ºæšä¸¾ç±»â€å¯¹è±¡ï¼›    
// å¦åˆ™ï¼Œè¿”å›æ­£å¸¸çš„Enumeratorçš„å¯¹è±¡ã€‚
private <T> Enumeration<T> getEnumeration(int type) {
    if (count == 0) {
        return Collections.emptyEnumeration();
    } else {
        return new Enumerator<>(type, false);
    }
}
 
// è·å–Hashtableçš„è¿­ä»£å™¨    
// è‹¥Hashtableçš„å®é™…å¤§å°ä¸º0,åˆ™è¿”å›â€œç©ºè¿­ä»£å™¨â€å¯¹è±¡ï¼›    
// å¦åˆ™ï¼Œè¿”å›æ­£å¸¸çš„Enumeratorçš„å¯¹è±¡ã€‚(Enumeratorå®ç°äº†è¿­ä»£å™¨å’Œæšä¸¾ä¸¤ä¸ªæ¥å£) 
private <T> Iterator<T> getIterator(int type) {
    if (count == 0) {
        return Collections.emptyIterator();
    } else {
        return new Enumerator<>(type, true);
    }
}
 
 
// Enumeratorçš„ä½œç”¨æ˜¯æä¾›äº†â€œé€šè¿‡elements()éå†Hashtableçš„æ¥å£â€ å’Œ â€œé€šè¿‡entrySet()éå†Hashtableçš„æ¥å£â€ã€‚    
private class Enumerator<T> implements Enumeration<T>, Iterator<T> {
    // æŒ‡å‘Hashtableçš„table   
    Entry<?,?>[] table = Hashtable.this.table;
    // Hashtableçš„æ€»çš„å¤§å°  
    int index = table.length;
    Entry<?,?> entry;
    Entry<?,?> lastReturned;
    int type;

    // Enumeratoræ˜¯ â€œè¿­ä»£å™¨(Iterator)â€ è¿˜æ˜¯ â€œæšä¸¾ç±»(Enumeration)â€çš„æ ‡å¿—    
    // iteratorä¸ºtrueï¼Œè¡¨ç¤ºå®ƒæ˜¯è¿­ä»£å™¨ï¼›å¦åˆ™ï¼Œæ˜¯æšä¸¾ç±»ã€‚
    boolean iterator;

    // åœ¨å°†Enumeratorå½“ä½œè¿­ä»£å™¨ä½¿ç”¨æ—¶ä¼šç”¨åˆ°ï¼Œç”¨æ¥å®ç°fail-fastæœºåˆ¶
    protected int expectedModCount = modCount;

    Enumerator(int type, boolean iterator) {
        this.type = type;
        this.iterator = iterator;
    }

    // ä»éå†tableçš„æ•°ç»„çš„æœ«å°¾å‘å‰æŸ¥æ‰¾ï¼Œç›´åˆ°æ‰¾åˆ°ä¸ä¸ºnullçš„Entryã€‚  
    public boolean hasMoreElements() {
        Entry<?,?> e = entry;
        int i = index;
        Entry<?,?>[] t = table;
        /* Use locals for faster loop iteration */
        while (e == null && i > 0) {
            e = t[--i];
        }
        entry = e;
        index = i;
        return e != null;
    }

    // è·å–ä¸‹ä¸€ä¸ªå…ƒç´     
    // æ³¨æ„ï¼šä»hasMoreElements() å’ŒnextElement() å¯ä»¥çœ‹å‡ºâ€œHashtableçš„elements()éå†æ–¹å¼â€    
    // é¦–å…ˆï¼Œ<span style="color:#ff0000;">ä»åå‘å‰çš„éå†tableæ•°ç»„</span>ã€‚tableæ•°ç»„çš„æ¯ä¸ªèŠ‚ç‚¹éƒ½æ˜¯ä¸€ä¸ªå•å‘é“¾è¡¨(Entry)ã€‚    
    // ç„¶åï¼Œä¾æ¬¡å‘åéå†å•å‘é“¾è¡¨Entryã€‚    
    @SuppressWarnings("unchecked")
    public T nextElement() {
        Entry<?,?> et = entry;
        int i = index;
        Entry<?,?>[] t = table;
        /* Use locals for faster loop iteration */
        while (et == null && i > 0) {
            et = t[--i];
        }
        entry = et;
        index = i;
        if (et != null) {
            Entry<?,?> e = lastReturned = entry;
            entry = e.next;
            return type == KEYS ? (T)e.key : (type == VALUES ? (T)e.value : (T)e);
        }
        throw new NoSuchElementException("Hashtable Enumerator");
    }

    // Iterator methods
    public boolean hasNext() {
        return hasMoreElements();
    }

    public T next() {
        if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
        return nextElement();
    }

    public void remove() {
        if (!iterator)
            throw new UnsupportedOperationException();
        if (lastReturned == null)
            throw new IllegalStateException("Hashtable Enumerator");
        if (modCount != expectedModCount)
            throw new ConcurrentModificationException();

        synchronized(Hashtable.this) {
            Entry<?,?>[] tab = Hashtable.this.table;
            int index = (lastReturned.hash & 0x7FFFFFFF) % tab.length;

            @SuppressWarnings("unchecked")
            Entry<K,V> e = (Entry<K,V>)tab[index];
            for(Entry<K,V> prev = null; e != null; prev = e, e = e.next) {
                if (e == lastReturned) {
                    modCount++;
                    expectedModCount++;
                    if (prev == null)
                        tab[index] = e.next;
                    else
                        prev.next = e.next;
                    count--;
                    lastReturned = null;
                    return;
                }
            }
            throw new ConcurrentModificationException();
        }
    }
}
```
**Hashtable ä¸­çš„æ–¹æ³•ä½¿ç”¨äº† `synchronized` å…³é”®å­—ä¿®é¥°ï¼Œå› æ­¤ `Hashtableæ˜¯çº¿ç¨‹å®‰å…¨çš„`ã€‚**

* éå†æ–¹å¼
```
Hashtableçš„éå†æ–¹å¼æ¯”è¾ƒç®€å•ï¼Œä¸€èˆ¬åˆ†ä¸¤æ­¥ï¼š
   1. è·å¾— Entry æˆ– key æˆ– value çš„é›†åˆï¼›
   2. é€šè¿‡ Iterator è¿­ä»£å™¨æˆ–è€… Enumeration éå†æ­¤é›†åˆ
```

1. éå† HashTable çš„ Entry ï¼ˆæ•ˆç‡é«˜ï¼‰

```
Object key = null;
Object value = null;
HashTable table = new HashTable();
Iterator iterator = table.entrySet().iterator();
while(iterator.hasNext()) {
    Map.Entry entry = (Map.Entry)iterator.next();
    // è·å–key
    key = entry.getKey();
    // è·å–value
    value = entry.getValue();
}
```

2. éå† HashTable çš„ key

```
Object key = null;
Object value = null;
HashTable table = new HashTable();
Iterator iterator = table.keySet().iterator();
while (iterator.hasNext()) {
    // è·å–key
    key = iterator.next();
    // æ ¹æ®keyï¼Œè·å–value
    value = table.get(key);
}
```

3. éå† HashTable çš„ value

```
Object value = null;
HashTable table = new HashTable();
Collection c = table.values();
Iterator iterator= c.iterator();
while (iterator.hasNext()) {
    value = iterator.next();
}
```

4. é€šè¿‡ Enumeration éå† HashTable çš„ keyï¼ˆæ•ˆç‡é«˜ï¼‰

```
HashTable table = new HashTable();
Enumeration enumeration = table.keys();
while(enumeration.hasMoreElements()) {
    System.out.println(enumeration.nextElement());
}
```

5. é€šè¿‡ Enumeration éå† HashTable çš„ value ï¼ˆæ•ˆç‡é«˜ï¼‰

```
HashTable table = new HashTable();
Enumeration enumeration = table.elements();
while(enumeration.hasMoreElements()) {
    System.out.println(enumeration.nextElement());
}
```

**ç»¼ä¸Šæ‰€è¿°ï¼ŒHashtableæ˜¯ä¸€ä¸ª `æ•£åˆ—è¡¨`ï¼Œå®ƒå­˜å‚¨çš„å†…å®¹æ˜¯ `é”®å€¼å¯¹(k-v)æ˜ å°„`ã€‚Hashtable `ä¸å…è®¸nullå¯¹è±¡` ä¸” `Hashtableæ˜¯çº¿ç¨‹å®‰å…¨çš„`ã€‚å…³äºå®ƒçš„ä»‹ç»å°±å‘Šä¸€æ®µè½ï¼Œå¸Œæœ›å¯¹å¤§å®¶æœ‰æ‰€å¸®åŠ©ï¼ï¼ï¼**

----

> æ–‡ç« å¯ä»¥ç™½å«–ï¼Œè€é“ä»¬é¡ºä¾¿å…³æ³¨ä¸€ä¸‹æˆ‘çš„å…¬ä¼—å·ï¼Œæ‰‹åŠ¨æ»‘ç¨½ğŸ¤£ğŸ¤£ &nbsp;
>
> æ¬¢è¿å¤§å®¶å…³æ³¨ï¼š**æ­¦å“¥èŠç¼–ç¨‹**ã€**Javaå¼€å‘å®å…¸**ã€**Javaç§ƒå¤´å“¥**ï¼Œæ‚¨çš„æ”¯æŒï¼Œæ˜¯æˆ‘åˆ›ä½œçš„æŒç»­åŠ¨åŠ›ï¼&nbsp;&nbsp;

![å…¬ä¼—å·äºŒç»´ç ](https://img-blog.csdnimg.cn/20201121225359995.png)





