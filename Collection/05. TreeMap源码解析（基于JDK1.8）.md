> æ–‡ç« å¯ä»¥ç™½å«–ï¼Œè€é“ä»¬é¡ºä¾¿å…³æ³¨ä¸€ä¸‹æˆ‘çš„å…¬ä¼—å·ï¼Œæ‰‹åŠ¨æ»‘ç¨½ğŸ¤£ğŸ¤£ &nbsp;
>
> æ¬¢è¿å¤§å®¶å…³æ³¨ï¼š**æ­¦å“¥èŠç¼–ç¨‹**ã€**Javaå¼€å‘å®å…¸**ã€**Javaç§ƒå¤´å“¥**ï¼Œæ‚¨çš„æ”¯æŒï¼Œæ˜¯æˆ‘åˆ›ä½œçš„æŒç»­åŠ¨åŠ›ï¼&nbsp;&nbsp;

![å…¬ä¼—å·äºŒç»´ç ](https://img-blog.csdnimg.cn/20201121225359995.png)

----

# TreeMap

`TreeMap` æ˜¯ä¸€ä¸ª `æœ‰åºçš„key-valueé›†åˆ`ï¼Œæ˜¯ `éçº¿ç¨‹å®‰å…¨` çš„ï¼ŒåŸºäº`çº¢é»‘æ ‘ï¼ˆRed-Blacktreeï¼‰`å®ç°ã€‚å…¶æ˜ å°„æ ¹æ®é”®çš„è‡ªç„¶é¡ºåºè¿›è¡Œæ’åºï¼Œæˆ–è€…æ ¹æ®åˆ›å»ºæ˜ å°„æ—¶æä¾›çš„ Comparator è¿›è¡Œæ’åºï¼Œå…·ä½“å–å†³äºä½¿ç”¨çš„æ„é€ æ–¹æ³•ã€‚å…¶åŸºæœ¬æ“ä½œ containsKeyã€getã€put å’Œ remove çš„æ—¶é—´å¤æ‚åº¦æ˜¯ log(n) ã€‚

## æ•°æ®ç»“æ„

![image](http://note.youdao.com/yws/public/resource/07a596690165d28c75671b1363b80262/xmlnote/E47F3E72687141379066FAB646933C5D/13284)

> ç±»å®šä¹‰ 

* TreeMap<K,V>: TreeMapæ˜¯ä»¥key-valueå½¢å¼å­˜å‚¨æ•°æ®çš„ã€‚
* extends AbstractMap<K,V>: ç»§æ‰¿äº†AbstractMap,å‡å°‘äº†å®ç°Mapæ¥å£æ—¶éœ€è¦çš„å·¥ä½œé‡ã€‚
* implements NavigableMap<K,V>: å®ç°äº†SortedMap,æ”¯æŒä¸€ç³»åˆ—å¯¼èˆªæ–¹æ³•ã€‚
* implements Cloneable: è¡¨æ˜å…¶å¯ä»¥è°ƒç”¨å…‹éš†æ–¹æ³•clone()è¿”å›å®ä¾‹çš„field-for-fieldæ‹·è´ã€‚
* implements Serializable: è¡¨æ˜è¯¥ç±»æ˜¯å¯ä»¥åºåˆ—åŒ–çš„ã€‚

> Entry å®ä½“

**`TreeMap` çš„ `Entry` å…¶å®æ˜¯ çº¢-é»‘æ ‘çš„ä¸€ä¸ªèŠ‚ç‚¹**

```java
static final class Entry<K,V> implements Map.Entry<K,V> {
    K key; // é”®
    V value; // å€¼
    Entry<K,V> left;  // æŒ‡å‘å·¦å­æ ‘çš„å¼•ç”¨ï¼ˆæŒ‡é’ˆï¼‰
    Entry<K,V> right; // æŒ‡å‘å³å­æ ‘çš„å¼•ç”¨ï¼ˆæŒ‡é’ˆï¼‰
    Entry<K,V> parent; // æŒ‡å‘çˆ¶èŠ‚ç‚¹çš„å¼•ç”¨ï¼ˆæŒ‡é’ˆï¼‰
    boolean color = BLACK; // èŠ‚ç‚¹é¢œè‰²ï¼Œé»˜è®¤é»‘è‰²  

    // æ„é€ æ–¹æ³•
    Entry(K key, V value, Entry<K,V> parent) {
        this.key = key;
        this.value = value;
        this.parent = parent;
    }
    
    // è·å– key
    public K getKey() {
        return key;
    }
   
    // è·å– value
    public V getValue() {
        return value;
    }
   
    // è®¾ç½® value
    public V setValue(V value) {
        V oldValue = this.value;
        this.value = value;
        return oldValue;
    }
   
    // kv éƒ½ç›¸ç­‰æ‰ç®—ç›¸ç­‰
    public boolean equals(Object o) {
        if (!(o instanceof Map.Entry))
            return false;
        Map.Entry<?,?> e = (Map.Entry<?,?>)o;

        return valEquals(key,e.getKey()) && valEquals(value,e.getValue());
    }

    // è®¡ç®— hashcode å€¼
    public int hashCode() {
        int keyHash = (key==null ? 0 : key.hashCode());
        int valueHash = (value==null ? 0 : value.hashCode());
        return keyHash ^ valueHash;
    }
    
    // é‡å†™ toString æ–¹æ³•ï¼Œè¿”å›key=valueå½¢å¼
    public String toString() {
        return key + "=" + value;
    }
}
```

## æºç åˆ†æ

- æˆå‘˜å±æ€§

```java
/** 
 * ç”¨äºç»´æŠ¤æ­¤TreeMapä¸­é¡ºåºçš„æ¯”è¾ƒå™¨ï¼Œå¦‚æœå®ƒä¸ºnullï¼Œåˆ™ä½¿ç”¨keyçš„è‡ªç„¶é¡ºåºã€‚
 */
private final Comparator<? super K> comparator;
/**
 * æ ‘çš„æ ¹èŠ‚ç‚¹
 */
private transient Entry<K,V> root;
/**
 * æ ‘ä¸­èŠ‚ç‚¹çš„ä¸ªæ•°
 */
private transient int size = 0;
/**
 * æ ‘è¿›è¡Œç»“æ„æ€§ä¿®æ”¹çš„æ¬¡æ•°
 */
private transient int modCount = 0;

ã€€// çº¢é»‘æ ‘èŠ‚ç‚¹é¢œè‰²
private static final boolean RED = false;
private static final boolean BLACK = true;
```

- æ„é€ å‡½æ•°

```java
/**
 * é»˜è®¤æ„é€ å‡½æ•°ã€‚ä½¿ç”¨é»˜è®¤æ¯”è¾ƒå™¨æ¯”è¾ƒkeyçš„å¤§å°ï¼ŒTreeMapä¸­çš„å…ƒç´ æŒ‰ç…§è‡ªç„¶æ’åºè¿›è¡Œæ’åˆ—ã€‚
 */
public TreeMap() {
    // é»˜è®¤æ¯”è¾ƒæœºåˆ¶
    comparator = null;
}

/**
 *  å¸¦æ¯”è¾ƒå™¨çš„æ„é€ å‡½æ•°
 */
public TreeMap(Comparator<? super K> comparator) {
    this.comparator = comparator;
}

/**
 *  å¸¦Mapçš„æ„é€ å‡½æ•°ï¼ŒMapä¼šæˆä¸ºTreeMapçš„å­é›†
 */
public TreeMap(Map<? extends K, ? extends V> m) {
    comparator = null;
    putAll(m);
}

/**
 * å¸¦SortedMapçš„æ„é€ å‡½æ•°ï¼ŒSortedMapä¼šæˆä¸ºTreeMapçš„å­é›†
 */
public TreeMap(SortedMap<K, ? extends V> m) {
    // ä½¿ç”¨å·²çŸ¥å¯¹è±¡çš„æ¯”è¾ƒå™¨
    comparator = m.comparator();
    try {
        buildFromSorted(m.size(), m.entrySet().iterator(), null, null);
    } catch (java.io.IOException cannotHappen) {
    } catch (ClassNotFoundException cannotHappen) {
    }
}
```
- å­˜å–æ–¹æ³•

1. put æ–¹æ³•

```java
/**
 *  æ’å…¥æ“ä½œ
 */
public V put(K key, V value) {
    Entry<K,V> t = root;
    // è‹¥çº¢é»‘æ ‘ä¸ºç©ºï¼Œç›´æ¥æ·»åŠ æ ¹èŠ‚ç‚¹
    if (t == null) {
        compare(key, key); // type (and possibly null) check

        root = new Entry<>(key, value, null);
        size = 1;
        modCount++;
        return null;
    }
    int cmp;
    Entry<K,V> parent;
    // åœ¨çº¢é»‘æ ‘ä¸­æ‰¾åˆ°æ’å…¥çš„ä½ç½®
    Comparator<? super K> cpr = comparator;
    if (cpr != null) {
        do {
            parent = t;
            cmp = cpr.compare(key, t.key);
            if (cmp < 0)
                t = t.left;
            else if (cmp > 0)
                t = t.right;
            else
                return t.setValue(value);
        } while (t != null);
    }
    else {
        if (key == null)
            throw new NullPointerException();
        @SuppressWarnings("unchecked")
            Comparable<? super K> k = (Comparable<? super K>) key;
        do {
            parent = t;
            cmp = k.compareTo(t.key);
            if (cmp < 0)
                t = t.left;
            else if (cmp > 0)
                t = t.right;
            else
                return t.setValue(value);
        } while (t != null);
    }
    // æ–°å»ºçº¢é»‘æ ‘çš„èŠ‚ç‚¹e
    Entry<K,V> e = new Entry<>(key, value, parent);
    if (cmp < 0)
        parent.left = e;
    else
        parent.right = e;
    fixAfterInsertion(e); //æ’å…¥æ–°èŠ‚ç‚¹åï¼Œè¦é‡æ–°ä¿®å¤çº¢é»‘æ ‘çš„ç‰¹æ€§
    size++;
    modCount++;
    return null;
}

/** 
 * æ’å…¥æ–°èŠ‚ç‚¹åçš„ä¿®æ­£æ“ä½œï¼Œä¿è¯çº¢é»‘æ ‘çš„å¹³è¡¡æ€§
 * è·Ÿçº¢é»‘æ ‘ä¸­çš„ä¿®æ­£æ–¹å¼ä¸€æ ·çš„
 */
private void fixAfterInsertion(Entry<K,V> x) {
    x.color = RED;

    while (x != null && x != root && x.parent.color == RED) {
        if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {
            Entry<K,V> y = rightOf(parentOf(parentOf(x)));
            if (colorOf(y) == RED) {
                setColor(parentOf(x), BLACK);
                setColor(y, BLACK);
                setColor(parentOf(parentOf(x)), RED);
                x = parentOf(parentOf(x));
            } else {
                if (x == rightOf(parentOf(x))) {
                    x = parentOf(x);
                    rotateLeft(x);
                }
                setColor(parentOf(x), BLACK);
                setColor(parentOf(parentOf(x)), RED);
                rotateRight(parentOf(parentOf(x)));
            }
        } else {
            Entry<K,V> y = leftOf(parentOf(parentOf(x)));
            if (colorOf(y) == RED) {
                setColor(parentOf(x), BLACK);
                setColor(y, BLACK);
                setColor(parentOf(parentOf(x)), RED);
                x = parentOf(parentOf(x));
            } else {
                if (x == leftOf(parentOf(x))) {
                    x = parentOf(x);
                    rotateRight(x);
                }
                setColor(parentOf(x), BLACK);
                setColor(parentOf(parentOf(x)), RED);
                rotateLeft(parentOf(parentOf(x)));
            }
        }
    }
    root.color = BLACK;
}

/** å·¦æ—‹æ“ä½œ */
private void rotateLeft(Entry<K,V> p) {
    if (p != null) {
        Entry<K,V> r = p.right;
        p.right = r.left;
        if (r.left != null)
            r.left.parent = p;
        r.parent = p.parent;
        if (p.parent == null)
            root = r;
        else if (p.parent.left == p)
            p.parent.left = r;
        else
            p.parent.right = r;
        r.left = p;
        p.parent = r;
    }
}

/** å³æ—‹æ“ä½œ */
private void rotateRight(Entry<K,V> p) {
    if (p != null) {
        Entry<K,V> l = p.left;
        p.left = l.right;
        if (l.right != null) l.right.parent = p;
        l.parent = p.parent;
        if (p.parent == null)
            root = l;
        else if (p.parent.right == p)
            p.parent.right = l;
        else p.parent.left = l;
        l.right = p;
        p.parent = l;
    }
}
```

2. get æ–¹æ³•

```java
/**
 * æ ¹æ® key è·å– value
 */
public V get(Object key) {
    Entry<K,V> p = getEntry(key);
    return (p==null ? null : p.value);
}

final Entry<K,V> getEntry(Object key) {
    // è‡ªå®šä¹‰æ¯”è¾ƒå™¨ï¼Œå¦åˆ™ä½¿ç”¨é»˜è®¤è‡ªç„¶åº
    if (comparator != null)
        return getEntryUsingComparator(key);
    // key ä¸èƒ½ä¸º null
    if (key == null)
        throw new NullPointerException();
    @SuppressWarnings("unchecked")
        Comparable<? super K> k = (Comparable<? super K>) key;
    Entry<K,V> p = root;
    while (p != null) {
        int cmp = k.compareTo(p.key);
        if (cmp < 0)
            p = p.left;
        else if (cmp > 0)
            p = p.right;
        else
            return p;
    }
    return null;
}

final Entry<K,V> getEntryUsingComparator(Object key) {
    @SuppressWarnings("unchecked")
        K k = (K) key;
    Comparator<? super K> cpr = comparator;
    if (cpr != null) {
        Entry<K,V> p = root;
        while (p != null) {
            int cmp = cpr.compare(k, p.key);
            if (cmp < 0)
                p = p.left;
            else if (cmp > 0)
                p = p.right;
            else
                return p;
        }
    }
    return null;
}
```

3. å…¶ä»–æ–¹æ³•

```java
/**
 * è·å–æ ‘èŠ‚ç‚¹ä¸ªæ•°
 */
public int size() {
	return size;
}
 
/**
 *  TreeMap ä¸­æ˜¯å¦åŒ…å«æŒ‡å®šçš„ key
 */
public boolean containsKey(Object key) {
	return getEntry(key) != null;
}
 
/**
 *  TreeMap ä¸­æ˜¯å¦åŒ…å«æŒ‡å®šçš„ value
 */
public boolean containsValue(Object value) {
	//ä»æœ€å°çš„èŠ‚ç‚¹å¼€å§‹æ‰¾
	for (Entry<K,V> e = getFirstEntry(); e != null; e = successor(e))
		if (valEquals(value, e.value))
			return true;
	return false;
}

/**
 *  è·å–æ¯”è¾ƒå™¨
 */
public Comparator<? super K> comparator() {
	return comparator;
}
 
/**
 *  è·å–ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å¯¹åº”çš„key
 */
public K firstKey() {
	return key(getFirstEntry());
}

/**
 *  è·å–æœ€åç¬¬ä¸€ä¸ªèŠ‚ç‚¹å¯¹åº”çš„key
 */
public K lastKey() {
	return key(getLastEntry());
}

/**
 *  è·å–ä¸å¤§äºæŒ‡å®škeyçš„æœ€å¤§çš„é”®å€¼å¯¹æ‰€å¯¹åº”çš„key,ä¸å­˜åœ¨åˆ™è¿”å›null
 */
public K floorKey(K key) {
	return keyOrNull(getFloorEntry(key));
}

/**
 *  è·å–ä¸å¤§äºæŒ‡å®škeyçš„æœ€å°çš„é”®å€¼å¯¹æ‰€å¯¹åº”çš„key,ä¸å­˜åœ¨åˆ™è¿”å›null
 */
public K ceilingKey(K key) {
	return keyOrNull(getCeilingEntry(key));
}
 
/**
 *  è·å–å°äºæŒ‡å®škeyçš„æœ€å¤§çš„é”®å€¼å¯¹æ‰€å¯¹åº”çš„key,ä¸å­˜åœ¨åˆ™è¿”å›null
 */
public K lowerKey(K key) {
	return keyOrNull(getLowerEntry(key));
}

/**
 *  è·å–å¤§äºæŒ‡å®škeyçš„æœ€å°çš„é”®å€¼å¯¹æ‰€å¯¹åº”çš„key,ä¸å­˜åœ¨åˆ™è¿”å›null
 */
public K higherKey(K key) {
	return keyOrNull(getHigherEntry(key));
}
 
/** TreeMapçš„çº¢é»‘æ ‘èŠ‚ç‚¹å¯¹åº”çš„é›†åˆ */
private transient EntrySet entrySet = null;
/** navigableKeySetä¸ºKeySetå¯¼èˆªç±» */
private transient KeySet<K> navigableKeySet = null;
/** descendingMapä¸ºé”®å€¼å¯¹çš„å€’åº */
private transient NavigableMap<K,V> descendingMap = null;
 

/**
 *  è·å–æ‰€æœ‰çš„ key é›†åˆ
 */
public Set<K> keySet() {
	return navigableKeySet();
}
 
/**
 *  è·å–ã€å¯å¯¼èˆªã€‘çš„Keyçš„é›†åˆ
 *   -- å®é™…ä¸Šæ˜¯è¿”å›KeySetç±»çš„å¯¹è±¡ã€‚
 */
public NavigableSet<K> navigableKeySet() {
	KeySet<K> nks = navigableKeySet;
	return (nks != null) ? nks : (navigableKeySet = new KeySet(this));
}

/**
 *  è·å–å€’åºçš„Keyçš„é›†åˆ
 */
public NavigableSet<K> descendingKeySet() {
	return descendingMap().navigableKeySet();
} 

/**
 *  è·å–å€’å™ map ã€‚
 */
public NavigableMap<K, V> descendingMap() {
	NavigableMap<K, V> km = descendingMap;
	return (km != null) ? km :
		(descendingMap = new DescendingSubMap(this,
											  true, null, true,
											  true, null, true));
}

/**
 *  è·å– kvé”®å€¼å¯¹é›†åˆã€‚
 */
public Collection<V> values() {
	Collection<V> vs = values;
	return (vs != null) ? vs : (values = new Values());
}

/**
 *  TreeMapçš„å€¼çš„é›†åˆå¯¹åº”çš„ç±»ï¼Œå®ƒç»§æ‰¿äºAbstractCollection
 */
class Values extends AbstractCollection<V> {
	public Iterator<V> iterator() {
		return new ValueIterator(getFirstEntry());
	}
 
	public int size() {
		return TreeMap.this.size();
	}
 
	public boolean contains(Object o) {
		return TreeMap.this.containsValue(o);
	}
 
	public boolean remove(Object o) {
		for (Entry<K,V> e = getFirstEntry(); e != null; e = successor(e)) {
			if (valEquals(e.getValue(), o)) {
				deleteEntry(e);
				return true;
			}
		}
		return false;
	}
 
	public void clear() {
		TreeMap.this.clear();
	}
}
 
/**
 *  è·å– Entryé›†åˆï¼Œå®é™…ä¸Šæ˜¯è¿”å›EntrySetç±»çš„å¯¹è±¡ã€‚
 */
public Set<Map.Entry<K,V>> entrySet() {
	EntrySet es = entrySet;
	return (es != null) ? es : (entrySet = new EntrySet());
}

/**
 *  EntrySet
 */
class EntrySet extends AbstractSet<Map.Entry<K,V>> {
	public Iterator<Map.Entry<K,V>> iterator() {
		return new EntryIterator(getFirstEntry());
	}
 
	public boolean contains(Object o) {
		if (!(o instanceof Map.Entry))
			return false;
		Map.Entry<K,V> entry = (Map.Entry<K,V>) o;
		V value = entry.getValue();
		Entry<K,V> p = getEntry(entry.getKey());
		return p != null && valEquals(p.getValue(), value);
	}
 
	public boolean remove(Object o) {
		if (!(o instanceof Map.Entry))
			return false;
		Map.Entry<K,V> entry = (Map.Entry<K,V>) o;
		V value = entry.getValue();
		Entry<K,V> p = getEntry(entry.getKey());
		if (p != null && valEquals(p.getValue(), value)) {
			deleteEntry(p);
			return true;
		}
		return false;
	}
 
	public int size() {
		return TreeMap.this.size();
	}
 
	public void clear() {
		TreeMap.this.clear();
	}
}
 

/**
 *  è·å–å­ map
 *   1. èŒƒå›´ä»fromKey åˆ°toKey
 *   2. fromInclusiveæ˜¯æ˜¯å¦åŒ…å«fromKeyçš„æ ‡è®°
 *   3. toInclusiveæ˜¯æ˜¯å¦åŒ…å«toKeyçš„æ ‡è®°
 */
public NavigableMap<K,V> subMap(K fromKey, boolean fromInclusive,
								K toKey,   boolean toInclusive) {
	return new AscendingSubMap(this,
							   false, fromKey, fromInclusive,
							   false, toKey,   toInclusive);
}
 
/**
 *  è·å–mapå¤´éƒ¨
 *   1. èŒƒå›´ä»ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ åˆ° toKey
 *   2. inclusiveæ˜¯æ˜¯å¦åŒ…å«toKeyçš„æ ‡è®° 
 */
public NavigableMap<K,V> headMap(K toKey, boolean inclusive) {
	return new AscendingSubMap(this,
							   true,  null,  true,
							   false, toKey, inclusive);
}

/**
 *  è·å–mapå°¾éƒ¨
 *   1. ä» fromKey åˆ° æœ€åä¸€ä¸ªèŠ‚ç‚¹
 *   2. inclusiveæ˜¯æ˜¯å¦åŒ…å«fromKeyçš„æ ‡è®° 
 */
public NavigableMap<K,V> tailMap(K fromKey, boolean inclusive) {
	return new AscendingSubMap(this,
							   false, fromKey, inclusive,
							   true,  null,    true);
}

/**
 *  è·å–å­Map
 *   1. ä» fromKey åˆ° toKey
 *   2. åŒ…æ‹¬ fromKey ä¸åŒ…æ‹¬ toKey
 */
public SortedMap<K,V> subMap(K fromKey, K toKey) {
	return subMap(fromKey, true, toKey, false);
}
 
/**
 *  è·å– Map å¤´éƒ¨
 *   1. ä» ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ åˆ° toKey
 *   2. ä¸åŒ…æ‹¬ toKey
 */
public SortedMap<K,V> headMap(K toKey) {
	return headMap(toKey, false);
}
 
/**
 *  è·å– Map å°¾éƒ¨
 *   1. ä» fromKey åˆ° æœ€åä¸€ä¸ªèŠ‚ç‚¹
 *   2. åŒ…æ‹¬ fromKey
 */
public SortedMap<K,V> tailMap(K fromKey) {
	return tailMap(fromKey, true);
}
 
/**
 *  è¿”å›TreeMapçš„KEYç»„æˆçš„è¿­ä»£å™¨(é¡ºåº)
 */
Iterator<K> keyIterator() {
	return new KeyIterator(getFirstEntry());
}
 
/**
 *  è¿”å›TreeMapçš„KEYç»„æˆçš„è¿­ä»£å™¨(é€†åº)
 */
Iterator<K> descendingKeyIterator() {
	return new DescendingKeyIterator(getLastEntry());
}
 
/**
 *  è¿”å›TreeMapä¸­æ‰€æœ‰çš„KEYç»„æˆçš„é›†åˆ
 */
static final class KeySet<E> extends AbstractSet<E> implements NavigableSet<E> {
	private final NavigableMap<E, Object> m;
	KeySet(NavigableMap<E,Object> map) { m = map; }
 
	// å‡åºè¿­ä»£å™¨
	public Iterator<E> iterator() {
		// è‹¥æ˜¯TreeMapå¯¹è±¡ï¼Œåˆ™è°ƒç”¨TreeMapçš„è¿­ä»£å™¨keyIterator()
		// å¦åˆ™ï¼Œè°ƒç”¨TreeMapå­ç±»NavigableSubMapçš„è¿­ä»£å™¨keyIterator()
		if (m instanceof TreeMap)
			return ((TreeMap<E,Object>)m).keyIterator();
		else
			return (Iterator<E>)(((TreeMap.NavigableSubMap)m).keyIterator());
	}
	
	// é™åºè¿­ä»£å™¨
	public Iterator<E> descendingIterator() {
		// è‹¥æ˜¯TreeMapå¯¹è±¡ï¼Œåˆ™è°ƒç”¨TreeMapçš„è¿­ä»£å™¨descendingKeyIterator()
		// å¦åˆ™ï¼Œè°ƒç”¨TreeMapå­ç±»NavigableSubMapçš„è¿­ä»£å™¨descendingKeyIterator()
		if (m instanceof TreeMap)
			return ((TreeMap<E,Object>)m).descendingKeyIterator();
		else
			return (Iterator<E>)(((TreeMap.NavigableSubMap)m).descendingKeyIterator());
	}
 
	public int size() { return m.size(); }
	public boolean isEmpty() { return m.isEmpty(); }
	public boolean contains(Object o) { return m.containsKey(o); }
	public void clear() { m.clear(); }
	public E lower(E e) { return m.lowerKey(e); }
	public E floor(E e) { return m.floorKey(e); }
	public E ceiling(E e) { return m.ceilingKey(e); }
	public E higher(E e) { return m.higherKey(e); }
	public E first() { return m.firstKey(); }
	public E last() { return m.lastKey(); }
	public Comparator<? super E> comparator() { return m.comparator(); }
	public E pollFirst() {
		Map.Entry<E,Object> e = m.pollFirstEntry();
		return (e == null) ? null : e.getKey();
	}
	public E pollLast() {
		Map.Entry<E,Object> e = m.pollLastEntry();
		return (e == null) ? null : e.getKey();
	}
	public boolean remove(Object o) {
		int oldSize = size();
		m.remove(o);
		return size() != oldSize;
	}
	public NavigableSet<E> subSet(E fromElement, boolean fromInclusive,
								  E toElement,   boolean toInclusive) {
		return new KeySet<>(m.subMap(fromElement, fromInclusive,
									  toElement,   toInclusive));
	}
	public NavigableSet<E> headSet(E toElement, boolean inclusive) {
		return new KeySet<>(m.headMap(toElement, inclusive));
	}
	public NavigableSet<E> tailSet(E fromElement, boolean inclusive) {
		return new KeySet<>(m.tailMap(fromElement, inclusive));
	}
	public SortedSet<E> subSet(E fromElement, E toElement) {
		return subSet(fromElement, true, toElement, false);
	}
	public SortedSet<E> headSet(E toElement) {
		return headSet(toElement, false);
	}
	public SortedSet<E> tailSet(E fromElement) {
		return tailSet(fromElement, true);
	}
	public NavigableSet<E> descendingSet() {
		return new KeySet(m.descendingMap());
	}
}

/**
 *  TreeMapä¸­çš„ä¸€ä¸ªæŠ½è±¡è¿­ä»£å™¨ï¼Œå®ç°äº†ä¸€äº›é€šç”¨çš„æ¥å£
 */
abstract class PrivateEntryIterator<T> implements Iterator<T> {
	Entry<K,V> next;
	Entry<K,V> lastReturned;
	int expectedModCount;
 
	PrivateEntryIterator(Entry<K,V> first) {
		expectedModCount = modCount;
		lastReturned = null;
		next = first;
	}
 
	public final boolean hasNext() {
		return next != null;
	}
 
	final Entry<K,V> nextEntry() {
		Entry<K,V> e = next;
		if (e == null)
			throw new NoSuchElementException();
		if (modCount != expectedModCount)
			throw new ConcurrentModificationException();
		next = successor(e);
		lastReturned = e;
		return e;
	}
 
	final Entry<K,V> prevEntry() {
		Entry<K,V> e = next;
		if (e == null)
			throw new NoSuchElementException();
		if (modCount != expectedModCount)
			throw new ConcurrentModificationException();
		next = predecessor(e);
		lastReturned = e;
		return e;
	}
 
	public void remove() {
		if (lastReturned == null)
			throw new IllegalStateException();
		if (modCount != expectedModCount)
			throw new ConcurrentModificationException();
		// è¿™é‡Œé‡ç‚¹å¼ºè°ƒä¸€ä¸‹â€œä¸ºä»€ä¹ˆå½“lastReturnedçš„å·¦å³å­©å­éƒ½ä¸ä¸ºç©ºæ—¶ï¼Œè¦å°†å…¶èµ‹å€¼ç»™nextâ€ã€‚
		// ç›®çš„æ˜¯ä¸ºäº†â€œåˆ é™¤lastReturnedèŠ‚ç‚¹ä¹‹åï¼ŒnextèŠ‚ç‚¹æŒ‡å‘çš„ä»ç„¶æ˜¯ä¸‹ä¸€ä¸ªèŠ‚ç‚¹â€ã€‚
		// æ ¹æ®â€œçº¢é»‘æ ‘â€çš„ç‰¹æ€§å¯çŸ¥ï¼š
		// å½“è¢«åˆ é™¤èŠ‚ç‚¹æœ‰ä¸¤ä¸ªå„¿å­æ—¶ã€‚é‚£ä¹ˆï¼Œé¦–å…ˆæŠŠâ€œå®ƒçš„åç»§èŠ‚ç‚¹çš„å†…å®¹â€å¤åˆ¶ç»™â€œè¯¥èŠ‚ç‚¹çš„å†…å®¹â€ï¼›ä¹‹åï¼Œåˆ é™¤â€œå®ƒçš„åç»§èŠ‚ç‚¹â€ã€‚
		// è¿™æ„å‘³ç€â€œå½“è¢«åˆ é™¤èŠ‚ç‚¹æœ‰ä¸¤ä¸ªå„¿å­æ—¶ï¼Œåˆ é™¤å½“å‰èŠ‚ç‚¹ä¹‹åï¼Œ'æ–°çš„å½“å‰èŠ‚ç‚¹'å®é™…ä¸Šæ˜¯â€˜åŸæœ‰çš„åç»§èŠ‚ç‚¹(å³ä¸‹ä¸€ä¸ªèŠ‚ç‚¹)â€™â€ã€‚
		// è€Œæ­¤æ—¶nextä»ç„¶æŒ‡å‘"æ–°çš„å½“å‰èŠ‚ç‚¹"ã€‚ä¹Ÿå°±æ˜¯è¯´nextæ˜¯ä»ç„¶æ˜¯æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼›èƒ½ç»§ç»­éå†çº¢é»‘æ ‘ã€‚
		if (lastReturned.left != null && lastReturned.right != null)
			next = lastReturned;
		deleteEntry(lastReturned);
		expectedModCount = modCount;
		lastReturned = null;
	}
}
 
/**
 * TreeMapçš„Entryå¯¹åº”çš„è¿­ä»£å™¨
 */
final class EntryIterator extends PrivateEntryIterator<Map.Entry<K,V>> {
	EntryIterator(Entry<K,V> first) {
		super(first);
	}
	public Map.Entry<K,V> next() {
		return nextEntry();
	}
}
 
/**
 * TreeMapçš„Valueå¯¹åº”çš„è¿­ä»£å™¨
 */
final class ValueIterator extends PrivateEntryIterator<V> {
	ValueIterator(Entry<K,V> first) {
		super(first);
	}
	public V next() {
		return nextEntry().value;
	}
}
 
/**
 * TreeMapçš„KEYç»„æˆçš„è¿­ä»£å™¨(é¡ºåº)
 */
final class KeyIterator extends PrivateEntryIterator<K> {
	KeyIterator(Entry<K,V> first) {
		super(first);
	}
	public K next() {
		return nextEntry().key;
	}
}
 
/**
 * TreeMapçš„KEYç»„æˆçš„è¿­ä»£å™¨(é€†åº)
 */
final class DescendingKeyIterator extends PrivateEntryIterator<K> {
	DescendingKeyIterator(Entry<K,V> first) {
		super(first);
	}
	public K next() {
		return prevEntry().key;
	}
}
 
/**
 * æ¯”è¾ƒä¸¤ä¸ªå¯¹è±¡çš„å¤§å°
 */
final int compare(Object k1, Object k2) {
	return comparator==null ? ((Comparable<? super K>)k1).compareTo((K)k2)
		: comparator.compare((K)k1, (K)k2);
}
 
/**
 * åˆ¤æ–­ä¸¤ä¸ªå¯¹è±¡æ˜¯å¦ç›¸ç­‰
 */
static final boolean valEquals(Object o1, Object o2) {
	return (o1==null ? o2==null : o1.equals(o2));
}
 
/**
 * è¿”å›Key-Valueé”®å€¼å¯¹çš„ä¸€ä¸ªç®€å•æ‹·è´
 */
static <K,V> Map.Entry<K,V> exportEntry(TreeMap.Entry<K,V> e) {
	return (e == null) ? null :
		new AbstractMap.SimpleImmutableEntry<>(e);
}
 
/**
 *  è‹¥â€œé”®å€¼å¯¹â€ä¸ä¸ºnullï¼Œåˆ™è¿”å›KEYï¼›å¦åˆ™ï¼Œè¿”å›null
 */
static <K,V> K keyOrNull(TreeMap.Entry<K,V> e) {
	return (e == null) ? null : e.key;
}
 
/**
 *  è‹¥â€œé”®å€¼å¯¹â€ä¸ä¸ºnullï¼Œåˆ™è¿”å›KEYï¼›å¦åˆ™ï¼ŒæŠ›å‡ºå¼‚å¸¸
 */
static <K> K key(Entry<K,?> e) {
	if (e==null)
		throw new NoSuchElementException();
	return e.key;
}
 
private static final Object UNBOUNDED = new Object();
 
/**
 *  TreeMapçš„SubMapï¼Œå®ƒä¸€ä¸ªæŠ½è±¡ç±»ï¼Œå®ç°äº†å…¬å…±æ“ä½œã€‚
 *    -- åŒ…æ‹¬äº†"(å‡åº)AscendingSubMap"å’Œ"(é™åº)DescendingSubMap"
 */
abstract static class NavigableSubMap<K,V> extends AbstractMap<K,V>
	implements NavigableMap<K,V>, java.io.Serializable {
	// TreeMapçš„æ‹·è´
	final TreeMap<K,V> m;
 
	// loæ˜¯â€œå­MapèŒƒå›´çš„æœ€å°å€¼â€ï¼Œhiæ˜¯â€œå­MapèŒƒå›´çš„æœ€å¤§å€¼â€ï¼›
	// loInclusiveæ˜¯â€œæ˜¯å¦åŒ…å«loçš„æ ‡è®°â€ï¼ŒhiInclusiveæ˜¯â€œæ˜¯å¦åŒ…å«hiçš„æ ‡è®°â€
	// fromStartæ˜¯â€œè¡¨ç¤ºæ˜¯å¦ä»ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å¼€å§‹è®¡ç®—â€ï¼Œ
	// toEndæ˜¯â€œè¡¨ç¤ºæ˜¯å¦è®¡ç®—åˆ°æœ€åä¸€ä¸ªèŠ‚ç‚¹   
	final K lo, hi;
	final boolean fromStart, toEnd;
	final boolean loInclusive, hiInclusive;
 
	NavigableSubMap(TreeMap<K,V> m,
					boolean fromStart, K lo, boolean loInclusive,
					boolean toEnd,     K hi, boolean hiInclusive) {
		if (!fromStart && !toEnd) {
			if (m.compare(lo, hi) > 0)
				throw new IllegalArgumentException("fromKey > toKey");
		} else {
			if (!fromStart) // type check
				m.compare(lo, lo);
			if (!toEnd)
				m.compare(hi, hi);
		}
 
		this.m = m;
		this.fromStart = fromStart;
		this.lo = lo;
		this.loInclusive = loInclusive;
		this.toEnd = toEnd;
		this.hi = hi;
		this.hiInclusive = hiInclusive;
	}
 
	// åˆ¤æ–­keyæ˜¯å¦å¤ªå°
	final boolean tooLow(Object key) {
		// è‹¥è¯¥SubMapä¸åŒ…æ‹¬â€œèµ·å§‹èŠ‚ç‚¹â€ï¼Œ
		// å¹¶ä¸”ï¼Œâ€œkeyå°äºæœ€å°é”®(lo)â€æˆ–è€…â€œkeyç­‰äºæœ€å°é”®(lo)ï¼Œä½†æœ€å°é”®å´æ²¡åŒ…æ‹¬åœ¨è¯¥SubMapå†…â€
		// åˆ™åˆ¤æ–­keyå¤ªå°ã€‚å…¶ä½™æƒ…å†µéƒ½ä¸æ˜¯å¤ªå°ï¼
		if (!fromStart) {
			int c = m.compare(key, lo);
			if (c < 0 || (c == 0 && !loInclusive))
				return true;
		}
		return false;
	}
	
	// åˆ¤æ–­keyæ˜¯å¦å¤ªå¤§
	final boolean tooHigh(Object key) {
		// è‹¥è¯¥SubMapä¸åŒ…æ‹¬â€œç»“æŸèŠ‚ç‚¹â€ï¼Œ
		// å¹¶ä¸”ï¼Œâ€œkeyå¤§äºæœ€å¤§é”®(hi)â€æˆ–è€…â€œkeyç­‰äºæœ€å¤§é”®(hi)ï¼Œä½†æœ€å¤§é”®å´æ²¡åŒ…æ‹¬åœ¨è¯¥SubMapå†…â€
		// åˆ™åˆ¤æ–­keyå¤ªå¤§ã€‚å…¶ä½™æƒ…å†µéƒ½ä¸æ˜¯å¤ªå¤§ï¼
		if (!toEnd) {
			int c = m.compare(key, hi);
			if (c > 0 || (c == 0 && !hiInclusive))
				return true;
		}
		return false;
	}
	
	// åˆ¤æ–­keyæ˜¯å¦åœ¨â€œloå’Œhiâ€å¼€åŒºé—´èŒƒå›´å†…
	final boolean inRange(Object key) {
		return !tooLow(key) && !tooHigh(key);
	}
	
	// åˆ¤æ–­keyæ˜¯å¦åœ¨å°é—­åŒºé—´å†…
	final boolean inClosedRange(Object key) {
		return (fromStart || m.compare(key, lo) >= 0)
			&& (toEnd || m.compare(hi, key) >= 0);
	}
	
	// åˆ¤æ–­keyæ˜¯å¦åœ¨åŒºé—´å†…, inclusiveæ˜¯åŒºé—´å¼€å…³æ ‡å¿—
	final boolean inRange(Object key, boolean inclusive) {
		return inclusive ? inRange(key) : inClosedRange(key);
	}
 
	// è¿”å›æœ€ä½çš„Entry
	final TreeMap.Entry<K,V> absLowest() {
		// è‹¥â€œåŒ…å«èµ·å§‹èŠ‚ç‚¹â€ï¼Œåˆ™è°ƒç”¨getFirstEntry()è¿”å›ç¬¬ä¸€ä¸ªèŠ‚ç‚¹
		// å¦åˆ™çš„è¯ï¼Œè‹¥åŒ…æ‹¬loï¼Œåˆ™è°ƒç”¨getCeilingEntry(lo)è·å–å¤§äº/ç­‰äºloçš„æœ€å°çš„Entry;
		// å¦åˆ™ï¼Œè°ƒç”¨getHigherEntry(lo)è·å–å¤§äºloçš„æœ€å°Entry
		TreeMap.Entry<K,V> e =
			(fromStart ?  m.getFirstEntry() :
			 (loInclusive ? m.getCeilingEntry(lo) :
							m.getHigherEntry(lo)));
		return (e == null || tooHigh(e.key)) ? null : e;
	}
 
	// è¿”å›æœ€é«˜çš„Entry
	final TreeMap.Entry<K,V> absHighest() {
		// è‹¥â€œåŒ…å«ç»“æŸèŠ‚ç‚¹â€ï¼Œåˆ™è°ƒç”¨getLastEntry()è¿”å›æœ€åä¸€ä¸ªèŠ‚ç‚¹
		// å¦åˆ™çš„è¯ï¼Œè‹¥åŒ…æ‹¬hiï¼Œåˆ™è°ƒç”¨getFloorEntry(hi)è·å–å°äº/ç­‰äºhiçš„æœ€å¤§çš„Entry;
		//           å¦åˆ™ï¼Œè°ƒç”¨getLowerEntry(hi)è·å–å¤§äºhiçš„æœ€å¤§Entry
		TreeMap.Entry<K,V> e =
			(toEnd ?  m.getLastEntry() :
			 (hiInclusive ?  m.getFloorEntry(hi) :
							 m.getLowerEntry(hi)));
		return (e == null || tooLow(e.key)) ? null : e;
	}
	// è¿”å›"å¤§äº/ç­‰äºkeyçš„æœ€å°çš„Entry"
	final TreeMap.Entry<K,V> absCeiling(K key) {
		// åªæœ‰åœ¨â€œkeyå¤ªå°â€çš„æƒ…å†µä¸‹ï¼ŒabsLowest()è¿”å›çš„Entryæ‰æ˜¯â€œå¤§äº/ç­‰äºkeyçš„æœ€å°Entryâ€
		// å…¶å®ƒæƒ…å†µä¸‹ä¸è¡Œã€‚ä¾‹å¦‚ï¼Œå½“åŒ…å«â€œèµ·å§‹èŠ‚ç‚¹â€æ—¶ï¼ŒabsLowest()è¿”å›çš„æ˜¯æœ€å°Entryäº†ï¼
		if (tooLow(key))
			return absLowest();
		// è·å–â€œå¤§äº/ç­‰äºkeyçš„æœ€å°Entryâ€
		TreeMap.Entry<K,V> e = m.getCeilingEntry(key);
		return (e == null || tooHigh(e.key)) ? null : e;
	}
	
	// è¿”å›"å¤§äºkeyçš„æœ€å°çš„Entry"
	final TreeMap.Entry<K,V> absHigher(K key) {
		// åªæœ‰åœ¨â€œkeyå¤ªå°â€çš„æƒ…å†µä¸‹ï¼ŒabsLowest()è¿”å›çš„Entryæ‰æ˜¯â€œå¤§äºkeyçš„æœ€å°Entryâ€
		// å…¶å®ƒæƒ…å†µä¸‹ä¸è¡Œã€‚ä¾‹å¦‚ï¼Œå½“åŒ…å«â€œèµ·å§‹èŠ‚ç‚¹â€æ—¶ï¼ŒabsLowest()è¿”å›çš„æ˜¯æœ€å°Entryäº†,è€Œä¸ä¸€å®šæ˜¯â€œå¤§äºkeyçš„æœ€å°Entryâ€ï¼
		if (tooLow(key))
			return absLowest();
		// è·å–â€œå¤§äºkeyçš„æœ€å°Entryâ€
		TreeMap.Entry<K,V> e = m.getHigherEntry(key);
		return (e == null || tooHigh(e.key)) ? null : e;
	}
 
	// è¿”å›"å°äº/ç­‰äºkeyçš„æœ€å¤§çš„Entry"
	final TreeMap.Entry<K,V> absFloor(K key) {
		// åªæœ‰åœ¨â€œkeyå¤ªå¤§â€çš„æƒ…å†µä¸‹ï¼Œ(absHighest)è¿”å›çš„Entryæ‰æ˜¯â€œå°äº/ç­‰äºkeyçš„æœ€å¤§Entryâ€
		// å…¶å®ƒæƒ…å†µä¸‹ä¸è¡Œã€‚ä¾‹å¦‚ï¼Œå½“åŒ…å«â€œç»“æŸèŠ‚ç‚¹â€æ—¶ï¼ŒabsHighest()è¿”å›çš„æ˜¯æœ€å¤§Entryäº†ï¼
		if (tooHigh(key))
			return absHighest();
		// è·å–"å°äº/ç­‰äºkeyçš„æœ€å¤§çš„Entry"
		TreeMap.Entry<K,V> e = m.getFloorEntry(key);
		return (e == null || tooLow(e.key)) ? null : e;
	}
	
	// è¿”å›"å°äºkeyçš„æœ€å¤§çš„Entry"
	final TreeMap.Entry<K,V> absLower(K key) {
		// åªæœ‰åœ¨â€œkeyå¤ªå¤§â€çš„æƒ…å†µä¸‹ï¼Œ(absHighest)è¿”å›çš„Entryæ‰æ˜¯â€œå°äºkeyçš„æœ€å¤§Entryâ€
		// å…¶å®ƒæƒ…å†µä¸‹ä¸è¡Œã€‚ä¾‹å¦‚ï¼Œå½“åŒ…å«â€œç»“æŸèŠ‚ç‚¹â€æ—¶ï¼ŒabsHighest()è¿”å›çš„æ˜¯æœ€å¤§Entryäº†,è€Œä¸ä¸€å®šæ˜¯â€œå°äºkeyçš„æœ€å¤§Entryâ€ï¼
		if (tooHigh(key))
			return absHighest();
		// è·å–"å°äºkeyçš„æœ€å¤§çš„Entry"
		TreeMap.Entry<K,V> e = m.getLowerEntry(key);
		return (e == null || tooLow(e.key)) ? null : e;
	}
 
	// è¿”å›â€œå¤§äºæœ€å¤§èŠ‚ç‚¹ä¸­çš„æœ€å°èŠ‚ç‚¹â€ï¼Œä¸å­˜åœ¨çš„è¯ï¼Œè¿”å›null
	final TreeMap.Entry<K,V> absHighFence() {
		return (toEnd ? null : (hiInclusive ?
								m.getHigherEntry(hi) :
								m.getCeilingEntry(hi)));
	}
 
	// è¿”å›â€œå°äºæœ€å°èŠ‚ç‚¹ä¸­çš„æœ€å¤§èŠ‚ç‚¹â€ï¼Œä¸å­˜åœ¨çš„è¯ï¼Œè¿”å›null
	final TreeMap.Entry<K,V> absLowFence() {
		return (fromStart ? null : (loInclusive ?
									m.getLowerEntry(lo) :
									m.getFloorEntry(lo)));
	}
 
	// ä¸‹é¢å‡ ä¸ªabstractæ–¹æ³•æ˜¯éœ€è¦NavigableSubMapçš„å®ç°ç±»å®ç°çš„æ–¹æ³•
	abstract TreeMap.Entry<K,V> subLowest();
	abstract TreeMap.Entry<K,V> subHighest();
	abstract TreeMap.Entry<K,V> subCeiling(K key);
	abstract TreeMap.Entry<K,V> subHigher(K key);
	abstract TreeMap.Entry<K,V> subFloor(K key);
	abstract TreeMap.Entry<K,V> subLower(K key);
 
	// è¿”å›â€œé¡ºåºâ€çš„é”®è¿­ä»£å™¨
	abstract Iterator<K> keyIterator();
 
	// è¿”å›â€œé€†åºâ€çš„é”®è¿­ä»£å™¨
	abstract Iterator<K> descendingKeyIterator();
 
	// è¿”å›SubMapæ˜¯å¦ä¸ºç©ºã€‚ç©ºçš„è¯ï¼Œè¿”å›trueï¼Œå¦åˆ™è¿”å›false
	public boolean isEmpty() {
		return (fromStart && toEnd) ? m.isEmpty() : entrySet().isEmpty();
	}
	// è¿”å›SubMapçš„å¤§å°
	public int size() {
		return (fromStart && toEnd) ? m.size() : entrySet().size();
	}
	// è¿”å›SubMapæ˜¯å¦åŒ…å«é”®key
	public final boolean containsKey(Object key) {
		return inRange(key) && m.containsKey(key);
	}
	// å°†key-value æ’å…¥SubMapä¸­
	public final V put(K key, V value) {
		if (!inRange(key))
			throw new IllegalArgumentException("key out of range");
		return m.put(key, value);
	}
	// è·å–keyå¯¹åº”å€¼
	public final V get(Object key) {
		return !inRange(key) ? null :  m.get(key);
	}
	// åˆ é™¤keyå¯¹åº”çš„é”®å€¼å¯¹
	public final V remove(Object key) {
		return !inRange(key) ? null : m.remove(key);
	}
	// è·å–â€œå¤§äº/ç­‰äºkeyçš„æœ€å°é”®å€¼å¯¹â€
	public final Map.Entry<K,V> ceilingEntry(K key) {
		return exportEntry(subCeiling(key));
	}
	// è·å–â€œå¤§äº/ç­‰äºkeyçš„æœ€å°é”®â€
	public final K ceilingKey(K key) {
		return keyOrNull(subCeiling(key));
	}
	// è·å–â€œå¤§äºkeyçš„æœ€å°é”®å€¼å¯¹â€
	public final Map.Entry<K,V> higherEntry(K key) {
		return exportEntry(subHigher(key));
	}
	// è·å–â€œå¤§äºkeyçš„æœ€å°é”®â€
	public final K higherKey(K key) {
		return keyOrNull(subHigher(key));
	}
	// è·å–â€œå°äº/ç­‰äºkeyçš„æœ€å¤§é”®å€¼å¯¹â€
	public final Map.Entry<K,V> floorEntry(K key) {
		return exportEntry(subFloor(key));
	}
	// è·å–â€œå°äº/ç­‰äºkeyçš„æœ€å¤§é”®â€
	public final K floorKey(K key) {
		return keyOrNull(subFloor(key));
	}
	// è·å–â€œå°äºkeyçš„æœ€å¤§é”®å€¼å¯¹â€
	public final Map.Entry<K,V> lowerEntry(K key) {
		return exportEntry(subLower(key));
	}
	// è·å–â€œå°äºkeyçš„æœ€å¤§é”®â€
	public final K lowerKey(K key) {
		return keyOrNull(subLower(key));
	}
	// è·å–"SubMapçš„ç¬¬ä¸€ä¸ªé”®"
	public final K firstKey() {
		return key(subLowest());
	}
	// è·å–"SubMapçš„æœ€åä¸€ä¸ªé”®"
	public final K lastKey() {
		return key(subHighest());
	}
	// è·å–"SubMapçš„ç¬¬ä¸€ä¸ªé”®å€¼å¯¹"
	public final Map.Entry<K,V> firstEntry() {
		return exportEntry(subLowest());
	}
	// è·å–"SubMapçš„æœ€åä¸€ä¸ªé”®å€¼å¯¹"
	public final Map.Entry<K,V> lastEntry() {
		return exportEntry(subHighest());
	}
	// è¿”å›"SubMapçš„ç¬¬ä¸€ä¸ªé”®å€¼å¯¹"ï¼Œå¹¶ä»SubMapä¸­åˆ é™¤æ”¹é”®å€¼å¯¹
	public final Map.Entry<K,V> pollFirstEntry() {
		TreeMap.Entry<K,V> e = subLowest();
		Map.Entry<K,V> result = exportEntry(e);
		if (e != null)
			m.deleteEntry(e);
		return result;
	}
	// è¿”å›"SubMapçš„æœ€åä¸€ä¸ªé”®å€¼å¯¹"ï¼Œå¹¶ä»SubMapä¸­åˆ é™¤æ”¹é”®å€¼å¯¹
	public final Map.Entry<K,V> pollLastEntry() {
		TreeMap.Entry<K,V> e = subHighest();
		Map.Entry<K,V> result = exportEntry(e);
		if (e != null)
			m.deleteEntry(e);
		return result;
	}
 
	// Views
	transient NavigableMap<K,V> descendingMapView = null;
	transient EntrySetView entrySetView = null;
	transient KeySet<K> navigableKeySetView = null;
	// è¿”å›NavigableSetå¯¹è±¡ï¼Œå®é™…ä¸Šè¿”å›çš„æ˜¯å½“å‰å¯¹è±¡çš„"Keyé›†åˆ"ã€‚ 
	public final NavigableSet<K> navigableKeySet() {
		KeySet<K> nksv = navigableKeySetView;
		return (nksv != null) ? nksv :
			(navigableKeySetView = new TreeMap.KeySet(this));
	}
	// è¿”å›"Keyé›†åˆ"å¯¹è±¡
	public final Set<K> keySet() {
		return navigableKeySet();
	}
	// è¿”å›â€œé€†åºâ€çš„Keyé›†åˆ
	public NavigableSet<K> descendingKeySet() {
		return descendingMap().navigableKeySet();
	}
	// æ’åˆ—fromKey(åŒ…å«) åˆ° toKey(ä¸åŒ…å«) çš„å­map
	public final SortedMap<K,V> subMap(K fromKey, K toKey) {
		return subMap(fromKey, true, toKey, false);
	}
	// è¿”å›å½“å‰Mapçš„å¤´éƒ¨(ä»ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ åˆ° toKey, ä¸åŒ…æ‹¬toKey)
	public final SortedMap<K,V> headMap(K toKey) {
		return headMap(toKey, false);
	}
	// è¿”å›å½“å‰Mapçš„å°¾éƒ¨[ä» fromKey(åŒ…æ‹¬fromKeyKey) åˆ° æœ€åä¸€ä¸ªèŠ‚ç‚¹]
	public final SortedMap<K,V> tailMap(K fromKey) {
		return tailMap(fromKey, true);
	}
 
	// Mapçš„Entryçš„é›†åˆ
	abstract class EntrySetView extends AbstractSet<Map.Entry<K,V>> {
		private transient int size = -1, sizeModCount;
 
		public int size() {
			if (fromStart && toEnd)
				return m.size();
			if (size == -1 || sizeModCount != m.modCount) {
				sizeModCount = m.modCount;
				size = 0;
				Iterator i = iterator();
				while (i.hasNext()) {
					size++;
					i.next();
				}
			}
			return size;
		}
 
		public boolean isEmpty() {
			TreeMap.Entry<K,V> n = absLowest();
			return n == null || tooHigh(n.key);
		}
 
		public boolean contains(Object o) {
			if (!(o instanceof Map.Entry))
				return false;
			Map.Entry<K,V> entry = (Map.Entry<K,V>) o;
			K key = entry.getKey();
			if (!inRange(key))
				return false;
			TreeMap.Entry node = m.getEntry(key);
			return node != null &&
				valEquals(node.getValue(), entry.getValue());
		}
 
		public boolean remove(Object o) {
			if (!(o instanceof Map.Entry))
				return false;
			Map.Entry<K,V> entry = (Map.Entry<K,V>) o;
			K key = entry.getKey();
			if (!inRange(key))
				return false;
			TreeMap.Entry<K,V> node = m.getEntry(key);
			if (node!=null && valEquals(node.getValue(),
										entry.getValue())) {
				m.deleteEntry(node);
				return true;
			}
			return false;
		}
	}
 
	// SubMapçš„è¿­ä»£å™¨
	abstract class SubMapIterator<T> implements Iterator<T> {
		TreeMap.Entry<K,V> lastReturned;
		TreeMap.Entry<K,V> next;
		final Object fenceKey;
		int expectedModCount;
 
		SubMapIterator(TreeMap.Entry<K,V> first,
					   TreeMap.Entry<K,V> fence) {
			expectedModCount = m.modCount;
			lastReturned = null;
			next = first;
			fenceKey = fence == null ? UNBOUNDED : fence.key;
		}
 
		public final boolean hasNext() {
			return next != null && next.key != fenceKey;
		}
 
		final TreeMap.Entry<K,V> nextEntry() {
			TreeMap.Entry<K,V> e = next;
			if (e == null || e.key == fenceKey)
				throw new NoSuchElementException();
			if (m.modCount != expectedModCount)
				throw new ConcurrentModificationException();
			next = successor(e);
			lastReturned = e;
			return e;
		}
 
		final TreeMap.Entry<K,V> prevEntry() {
			TreeMap.Entry<K,V> e = next;
			if (e == null || e.key == fenceKey)
				throw new NoSuchElementException();
			if (m.modCount != expectedModCount)
				throw new ConcurrentModificationException();
			next = predecessor(e);
			lastReturned = e;
			return e;
		}
		// åˆ é™¤å½“å‰èŠ‚ç‚¹(ç”¨äºâ€œå‡åºçš„SubMapâ€)ã€‚
		// åˆ é™¤ä¹‹åï¼Œå¯ä»¥ç»§ç»­å‡åºéå†ï¼›çº¢é»‘æ ‘ç‰¹æ€§æ²¡å˜ã€‚
		final void removeAscending() {
			if (lastReturned == null)
				throw new IllegalStateException();
			if (m.modCount != expectedModCount)
				throw new ConcurrentModificationException();
			// è¿™é‡Œé‡ç‚¹å¼ºè°ƒä¸€ä¸‹â€œä¸ºä»€ä¹ˆå½“lastReturnedçš„å·¦å³å­©å­éƒ½ä¸ä¸ºç©ºæ—¶ï¼Œè¦å°†å…¶èµ‹å€¼ç»™nextâ€ã€‚
			// ç›®çš„æ˜¯ä¸ºäº†â€œåˆ é™¤lastReturnedèŠ‚ç‚¹ä¹‹åï¼ŒnextèŠ‚ç‚¹æŒ‡å‘çš„ä»ç„¶æ˜¯ä¸‹ä¸€ä¸ªèŠ‚ç‚¹â€ã€‚
			//     æ ¹æ®â€œçº¢é»‘æ ‘â€çš„ç‰¹æ€§å¯çŸ¥ï¼š
			//     å½“è¢«åˆ é™¤èŠ‚ç‚¹æœ‰ä¸¤ä¸ªå„¿å­æ—¶ã€‚é‚£ä¹ˆï¼Œé¦–å…ˆæŠŠâ€œå®ƒçš„åç»§èŠ‚ç‚¹çš„å†…å®¹â€å¤åˆ¶ç»™â€œè¯¥èŠ‚ç‚¹çš„å†…å®¹â€ï¼›ä¹‹åï¼Œåˆ é™¤â€œå®ƒçš„åç»§èŠ‚ç‚¹â€ã€‚
			//     è¿™æ„å‘³ç€â€œå½“è¢«åˆ é™¤èŠ‚ç‚¹æœ‰ä¸¤ä¸ªå„¿å­æ—¶ï¼Œåˆ é™¤å½“å‰èŠ‚ç‚¹ä¹‹åï¼Œ'æ–°çš„å½“å‰èŠ‚ç‚¹'å®é™…ä¸Šæ˜¯â€˜åŸæœ‰çš„åç»§èŠ‚ç‚¹(å³ä¸‹ä¸€ä¸ªèŠ‚ç‚¹)â€™â€ã€‚
			//     è€Œæ­¤æ—¶nextä»ç„¶æŒ‡å‘"æ–°çš„å½“å‰èŠ‚ç‚¹"ã€‚ä¹Ÿå°±æ˜¯è¯´nextæ˜¯ä»ç„¶æ˜¯æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼›èƒ½ç»§ç»­éå†çº¢é»‘æ ‘ã€‚
			if (lastReturned.left != null && lastReturned.right != null)
				next = lastReturned;
			m.deleteEntry(lastReturned);
			lastReturned = null;
			expectedModCount = m.modCount;
		}
		// åˆ é™¤å½“å‰èŠ‚ç‚¹(ç”¨äºâ€œé™åºçš„SubMapâ€)ã€‚
		// åˆ é™¤ä¹‹åï¼Œå¯ä»¥ç»§ç»­é™åºéå†ï¼›çº¢é»‘æ ‘ç‰¹æ€§æ²¡å˜ã€‚
		final void removeDescending() {
			if (lastReturned == null)
				throw new IllegalStateException();
			if (m.modCount != expectedModCount)
				throw new ConcurrentModificationException();
			m.deleteEntry(lastReturned);
			lastReturned = null;
			expectedModCount = m.modCount;
		}
 
	}
	// SubMapçš„Entryè¿­ä»£å™¨ï¼Œå®ƒåªæ”¯æŒå‡åºæ“ä½œï¼Œç»§æ‰¿äºSubMapIterator
	final class SubMapEntryIterator extends SubMapIterator<Map.Entry<K,V>> {
		SubMapEntryIterator(TreeMap.Entry<K,V> first,
							TreeMap.Entry<K,V> fence) {
			super(first, fence);
		}
		public Map.Entry<K,V> next() {
			return nextEntry();
		}
		public void remove() {
			removeAscending();
		}
	}
	// SubMapçš„Keyè¿­ä»£å™¨ï¼Œå®ƒåªæ”¯æŒå‡åºæ“ä½œï¼Œç»§æ‰¿äºSubMapIterator
	final class SubMapKeyIterator extends SubMapIterator<K> {
		SubMapKeyIterator(TreeMap.Entry<K,V> first,
						  TreeMap.Entry<K,V> fence) {
			super(first, fence);
		}
		// è·å–ä¸‹ä¸€ä¸ªèŠ‚ç‚¹(å‡åº)
		public K next() {
			return nextEntry().key;
		}
		// åˆ é™¤å½“å‰èŠ‚ç‚¹(å‡åº)
		public void remove() {
			removeAscending();
		}
	}
	// é™åºSubMapçš„Entryè¿­ä»£å™¨ï¼Œå®ƒåªæ”¯æŒé™åºæ“ä½œï¼Œç»§æ‰¿äºSubMapIterator
	final class DescendingSubMapEntryIterator extends SubMapIterator<Map.Entry<K,V>> {
		DescendingSubMapEntryIterator(TreeMap.Entry<K,V> last,
									  TreeMap.Entry<K,V> fence) {
			super(last, fence);
		}
		// è·å–ä¸‹ä¸€ä¸ªèŠ‚ç‚¹(é™åº)
		public Map.Entry<K,V> next() {
			return prevEntry();
		}
		// åˆ é™¤å½“å‰èŠ‚ç‚¹(é™åº)
		public void remove() {
			removeDescending();
		}
	}
	// é™åºSubMapçš„Keyè¿­ä»£å™¨ï¼Œå®ƒåªæ”¯æŒé™åºæ“ä½œï¼Œç»§æ‰¿äºSubMapIterator
	final class DescendingSubMapKeyIterator extends SubMapIterator<K> {
		DescendingSubMapKeyIterator(TreeMap.Entry<K,V> last,
									TreeMap.Entry<K,V> fence) {
			super(last, fence);
		}
		// è·å–ä¸‹ä¸€ä¸ªèŠ‚ç‚¹(é™åº)
		public K next() {
			return prevEntry().key;
		}
		// åˆ é™¤å½“å‰èŠ‚ç‚¹(é™åº)
		public void remove() {
			removeDescending();
		}
	}
}
 
// å‡åºçš„SubMapï¼Œç»§æ‰¿äºNavigableSubMap
static final class AscendingSubMap<K,V> extends NavigableSubMap<K,V> {
	private static final long serialVersionUID = 912986545866124060L;
 
	AscendingSubMap(TreeMap<K,V> m,
					boolean fromStart, K lo, boolean loInclusive,
					boolean toEnd,     K hi, boolean hiInclusive) {
		super(m, fromStart, lo, loInclusive, toEnd, hi, hiInclusive);
	}
 
	public Comparator<? super K> comparator() {
		return m.comparator();
	}
	// è·å–â€œå­Mapâ€ã€‚
	// èŒƒå›´æ˜¯ä»fromKey åˆ° toKeyï¼›fromInclusiveæ˜¯æ˜¯å¦åŒ…å«fromKeyçš„æ ‡è®°ï¼ŒtoInclusiveæ˜¯æ˜¯å¦åŒ…å«toKeyçš„æ ‡è®°
	public NavigableMap<K,V> subMap(K fromKey, boolean fromInclusive,
									K toKey,   boolean toInclusive) {
		if (!inRange(fromKey, fromInclusive))
			throw new IllegalArgumentException("fromKey out of range");
		if (!inRange(toKey, toInclusive))
			throw new IllegalArgumentException("toKey out of range");
		return new AscendingSubMap(m,
								   false, fromKey, fromInclusive,
								   false, toKey,   toInclusive);
	}
	
	// è·å–â€œMapçš„å¤´éƒ¨â€ã€‚
	// èŒƒå›´ä»ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ åˆ° toKey, inclusiveæ˜¯æ˜¯å¦åŒ…å«toKeyçš„æ ‡è®°
	public NavigableMap<K,V> headMap(K toKey, boolean inclusive) {
		if (!inRange(toKey, inclusive))
			throw new IllegalArgumentException("toKey out of range");
		return new AscendingSubMap(m,
								   fromStart, lo,    loInclusive,
								   false,     toKey, inclusive);
	}
	
	// è·å–â€œMapçš„å°¾éƒ¨â€ã€‚
	// èŒƒå›´æ˜¯ä» fromKey åˆ° æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œinclusiveæ˜¯æ˜¯å¦åŒ…å«fromKeyçš„æ ‡è®°
	public NavigableMap<K,V> tailMap(K fromKey, boolean inclusive) {
		if (!inRange(fromKey, inclusive))
			throw new IllegalArgumentException("fromKey out of range");
		return new AscendingSubMap(m,
								   false, fromKey, inclusive,
								   toEnd, hi,      hiInclusive);
	}
	// è·å–å¯¹åº”çš„é™åºMap
	public NavigableMap<K,V> descendingMap() {
		NavigableMap<K,V> mv = descendingMapView;
		return (mv != null) ? mv :
			(descendingMapView =
			 new DescendingSubMap(m,
								  fromStart, lo, loInclusive,
								  toEnd,     hi, hiInclusive));
	}
	// è¿”å›â€œå‡åºKeyè¿­ä»£å™¨â€
	Iterator<K> keyIterator() {
		return new SubMapKeyIterator(absLowest(), absHighFence());
	}
	// è¿”å›â€œé™åºKeyè¿­ä»£å™¨â€
	Iterator<K> descendingKeyIterator() {
		return new DescendingSubMapKeyIterator(absHighest(), absLowFence());
	}
	// â€œå‡åºEntrySeté›†åˆâ€ç±»
	// å®ç°äº†iterator()
	final class AscendingEntrySetView extends EntrySetView {
		public Iterator<Map.Entry<K,V>> iterator() {
			return new SubMapEntryIterator(absLowest(), absHighFence());
		}
	}
	// è¿”å›â€œå‡åºEntrySeté›†åˆâ€
	public Set<Map.Entry<K,V>> entrySet() {
		EntrySetView es = entrySetView;
		return (es != null) ? es : new AscendingEntrySetView();
	}
 
	TreeMap.Entry<K,V> subLowest()       { return absLowest(); }
	TreeMap.Entry<K,V> subHighest()      { return absHighest(); }
	TreeMap.Entry<K,V> subCeiling(K key) { return absCeiling(key); }
	TreeMap.Entry<K,V> subHigher(K key)  { return absHigher(key); }
	TreeMap.Entry<K,V> subFloor(K key)   { return absFloor(key); }
	TreeMap.Entry<K,V> subLower(K key)   { return absLower(key); }
}
 
// é™åºçš„SubMapï¼Œç»§æ‰¿äºNavigableSubMap
// ç›¸æ¯”äºå‡åºSubMapï¼Œå®ƒçš„å®ç°æœºåˆ¶æ˜¯å°†â€œSubMapçš„æ¯”è¾ƒå™¨åè½¬â€ï¼
static final class DescendingSubMap<K,V>  extends NavigableSubMap<K,V> {
	private static final long serialVersionUID = 912986545866120460L;
	DescendingSubMap(TreeMap<K,V> m,
					boolean fromStart, K lo, boolean loInclusive,
					boolean toEnd,     K hi, boolean hiInclusive) {
		super(m, fromStart, lo, loInclusive, toEnd, hi, hiInclusive);
	}
	// åè½¬çš„æ¯”è¾ƒå™¨ï¼šæ˜¯å°†åŸå§‹æ¯”è¾ƒå™¨åè½¬å¾—åˆ°çš„ã€‚
	private final Comparator<? super K> reverseComparator =
		Collections.reverseOrder(m.comparator);
	// è·å–åè½¬æ¯”è¾ƒå™¨
	public Comparator<? super K> comparator() {
		return reverseComparator;
	}
	// è·å–â€œå­Mapâ€ã€‚
	// èŒƒå›´æ˜¯ä»fromKey åˆ° toKeyï¼›fromInclusiveæ˜¯æ˜¯å¦åŒ…å«fromKeyçš„æ ‡è®°ï¼ŒtoInclusiveæ˜¯æ˜¯å¦åŒ…å«toKeyçš„æ ‡è®°
	public NavigableMap<K,V> subMap(K fromKey, boolean fromInclusive,
									K toKey,   boolean toInclusive) {
		if (!inRange(fromKey, fromInclusive))
			throw new IllegalArgumentException("fromKey out of range");
		if (!inRange(toKey, toInclusive))
			throw new IllegalArgumentException("toKey out of range");
		return new DescendingSubMap(m,
									false, toKey,   toInclusive,
									false, fromKey, fromInclusive);
	}
	// è·å–â€œMapçš„å¤´éƒ¨â€ã€‚
	// èŒƒå›´ä»ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ åˆ° toKey, inclusiveæ˜¯æ˜¯å¦åŒ…å«toKeyçš„æ ‡è®°
	public NavigableMap<K,V> headMap(K toKey, boolean inclusive) {
		if (!inRange(toKey, inclusive))
			throw new IllegalArgumentException("toKey out of range");
		return new DescendingSubMap(m,
									false, toKey, inclusive,
									toEnd, hi,    hiInclusive);
	}
	// è·å–â€œMapçš„å°¾éƒ¨â€ã€‚
	// èŒƒå›´æ˜¯ä» fromKey åˆ° æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œinclusiveæ˜¯æ˜¯å¦åŒ…å«fromKeyçš„æ ‡è®°
	public NavigableMap<K,V> tailMap(K fromKey, boolean inclusive) {
		if (!inRange(fromKey, inclusive))
			throw new IllegalArgumentException("fromKey out of range");
		return new DescendingSubMap(m,
									fromStart, lo, loInclusive,
									false, fromKey, inclusive);
	}
	// è·å–å¯¹åº”çš„é™åºMap
	public NavigableMap<K,V> descendingMap() {
		NavigableMap<K,V> mv = descendingMapView;
		return (mv != null) ? mv :
			(descendingMapView =
			 new AscendingSubMap(m,
								 fromStart, lo, loInclusive,
								 toEnd,     hi, hiInclusive));
	}
	// è¿”å›â€œå‡åºKeyè¿­ä»£å™¨â€
	Iterator<K> keyIterator() {
		return new DescendingSubMapKeyIterator(absHighest(), absLowFence());
	}
	// è¿”å›â€œé™åºKeyè¿­ä»£å™¨â€
	Iterator<K> descendingKeyIterator() {
		return new SubMapKeyIterator(absLowest(), absHighFence());
	}
	// â€œé™åºEntrySeté›†åˆâ€ç±»
	// å®ç°äº†iterator()
	final class DescendingEntrySetView extends EntrySetView {
		public Iterator<Map.Entry<K,V>> iterator() {
			return new DescendingSubMapEntryIterator(absHighest(), absLowFence());
		}
	}
	// è¿”å›â€œé™åºEntrySeté›†åˆâ€
	public Set<Map.Entry<K,V>> entrySet() {
		EntrySetView es = entrySetView;
		return (es != null) ? es : new DescendingEntrySetView();
	}
 
	TreeMap.Entry<K,V> subLowest()       { return absHighest(); }
	TreeMap.Entry<K,V> subHighest()      { return absLowest(); }
	TreeMap.Entry<K,V> subCeiling(K key) { return absFloor(key); }
	TreeMap.Entry<K,V> subHigher(K key)  { return absLower(key); }
	TreeMap.Entry<K,V> subFloor(K key)   { return absCeiling(key); }
	TreeMap.Entry<K,V> subLower(K key)   { return absHigher(key); }
}
// SubMapæ˜¯æ—§ç‰ˆæœ¬çš„ç±»ï¼Œæ–°çš„Javaä¸­æ²¡æœ‰ç”¨åˆ°ã€‚
private class SubMap extends AbstractMap<K,V>
	implements SortedMap<K,V>, java.io.Serializable {
	private static final long serialVersionUID = -6520786458950516097L;
	private boolean fromStart = false, toEnd = false;
	private K fromKey, toKey;
	private Object readResolve() {
		return new AscendingSubMap(TreeMap.this,
								   fromStart, fromKey, true,
								   toEnd, toKey, false);
	}
	public Set<Map.Entry<K,V>> entrySet() { throw new InternalError(); }
	public K lastKey() { throw new InternalError(); }
	public K firstKey() { throw new InternalError(); }
	public SortedMap<K,V> subMap(K fromKey, K toKey) { throw new InternalError(); }
	public SortedMap<K,V> headMap(K toKey) { throw new InternalError(); }
	public SortedMap<K,V> tailMap(K fromKey) { throw new InternalError(); }
	public Comparator<? super K> comparator() { throw new InternalError(); }
}
 
private static final boolean RED   = false;
private static final boolean BLACK = true;
 
// è¿”å›â€œèŠ‚ç‚¹tçš„åç»§èŠ‚ç‚¹â€
static <K,V> TreeMap.Entry<K,V> successor(Entry<K,V> t) {
	if (t == null)
		return null;
	else if (t.right != null) {
		Entry<K,V> p = t.right;
		while (p.left != null)
			p = p.left;
		return p;
	} else {
		Entry<K,V> p = t.parent;
		Entry<K,V> ch = t;
		while (p != null && ch == p.right) {
			ch = p;
			p = p.parent;
		}
		return p;
	}
}
 
// è¿”å›â€œèŠ‚ç‚¹tçš„å‰ç»§èŠ‚ç‚¹â€
static <K,V> Entry<K,V> predecessor(Entry<K,V> t) {
	if (t == null)
		return null;
	else if (t.left != null) {
		Entry<K,V> p = t.left;
		while (p.right != null)
			p = p.right;
		return p;
	} else {
		Entry<K,V> p = t.parent;
		Entry<K,V> ch = t;
		while (p != null && ch == p.left) {
			ch = p;
			p = p.parent;
		}
		return p;
	}
}
 
// è¿”å›â€œèŠ‚ç‚¹pçš„é¢œè‰²â€
// æ ¹æ®â€œçº¢é»‘æ ‘çš„ç‰¹æ€§â€å¯çŸ¥ï¼šç©ºèŠ‚ç‚¹é¢œè‰²æ˜¯é»‘è‰²ã€‚
private static <K,V> boolean colorOf(Entry<K,V> p) {
	return (p == null ? BLACK : p.color);
}
// è¿”å›â€œèŠ‚ç‚¹pçš„çˆ¶èŠ‚ç‚¹â€
private static <K,V> Entry<K,V> parentOf(Entry<K,V> p) {
	return (p == null ? null: p.parent);
}
// è®¾ç½®â€œèŠ‚ç‚¹pçš„é¢œè‰²ä¸ºcâ€
private static <K,V> void setColor(Entry<K,V> p, boolean c) {
	if (p != null)
		p.color = c;
}
// è®¾ç½®â€œèŠ‚ç‚¹pçš„å·¦å­©å­â€
private static <K,V> Entry<K,V> leftOf(Entry<K,V> p) {
	return (p == null) ? null: p.left;
}
// è®¾ç½®â€œèŠ‚ç‚¹pçš„å³å­©å­â€
private static <K,V> Entry<K,V> rightOf(Entry<K,V> p) {
	return (p == null) ? null: p.right;
}
 
private static final long serialVersionUID = 919286545866124006L;
 
// java.io.Serializableçš„å†™å…¥å‡½æ•°
// å°†TreeMapçš„â€œå®¹é‡ï¼Œæ‰€æœ‰çš„Entryâ€éƒ½å†™å…¥åˆ°è¾“å‡ºæµä¸­  
private void writeObject(java.io.ObjectOutputStream s)
	throws java.io.IOException {
	// Write out the Comparator and any hidden stuff
	s.defaultWriteObject();
 
	// Write out size (number of Mappings)
	s.writeInt(size);
 
	// Write out keys and values (alternating)
	for (Iterator<Map.Entry<K,V>> i = entrySet().iterator(); i.hasNext(); ) {
		Map.Entry<K,V> e = i.next();
		s.writeObject(e.getKey());
		s.writeObject(e.getValue());
	}
}
 
// java.io.Serializableçš„è¯»å–å‡½æ•°ï¼šæ ¹æ®å†™å…¥æ–¹å¼è¯»å‡º
// å…ˆå°†TreeMapçš„â€œå®¹é‡ã€æ‰€æœ‰çš„Entryâ€ä¾æ¬¡è¯»å‡º
private void readObject(final java.io.ObjectInputStream s)
	throws java.io.IOException, ClassNotFoundException {
	// Read in the Comparator and any hidden stuff
	s.defaultReadObject();
 
	// Read in size
	int size = s.readInt();
 
	buildFromSorted(size, null, s, null);
}
 
/** Intended to be called only from TreeSet.readObject */
void readTreeSet(int size, java.io.ObjectInputStream s, V defaultVal)
	throws java.io.IOException, ClassNotFoundException {
	buildFromSorted(size, null, s, defaultVal);
}
 
/** Intended to be called only from TreeSet.addAll */
void addAllForTreeSet(SortedSet<? extends K> set, V defaultVal) {
	try {
		buildFromSorted(set.size(), set.iterator(), null, defaultVal);
	} catch (java.io.IOException cannotHappen) {
	} catch (ClassNotFoundException cannotHappen) {
	}
}
// æ ¹æ®å·²ç»ä¸€ä¸ªæ’å¥½åºçš„mapåˆ›å»ºä¸€ä¸ªTreeMap
private void buildFromSorted(int size, Iterator it,
							 java.io.ObjectInputStream str,
							 V defaultVal)
	throws  java.io.IOException, ClassNotFoundException {
	this.size = size;
	root = buildFromSorted(0, 0, size-1, computeRedLevel(size),
						   it, str, defaultVal);
}
// æ ¹æ®å·²ç»ä¸€ä¸ªæ’å¥½åºçš„mapåˆ›å»ºä¸€ä¸ªTreeMap
// å°†mapä¸­çš„å…ƒç´ é€ä¸ªæ·»åŠ åˆ°TreeMapä¸­ï¼Œå¹¶è¿”å›mapçš„ä¸­é—´å…ƒç´ ä½œä¸ºæ ¹èŠ‚ç‚¹ã€‚
private final Entry<K,V> buildFromSorted(int level, int lo, int hi,
										 int redLevel,
										 Iterator it,
										 java.io.ObjectInputStream str,
										 V defaultVal)
	throws  java.io.IOException, ClassNotFoundException {
   
	if (hi < lo) return null;
	// è·å–ä¸­é—´å…ƒç´ 
	int mid = (lo + hi) >>> 1;
 
	Entry<K,V> left  = null;
	// è‹¥loå°äºmidï¼Œåˆ™é€’å½’è°ƒç”¨è·å–(middelçš„)å·¦å­©å­ã€‚
	if (lo < mid)
		left = buildFromSorted(level+1, lo, mid - 1, redLevel,
							   it, str, defaultVal);
 
	// è·å–middleèŠ‚ç‚¹å¯¹åº”çš„keyå’Œvalue
	K key;
	V value;
	if (it != null) {
		if (defaultVal==null) {
			Map.Entry<K,V> entry = (Map.Entry<K,V>)it.next();
			key = entry.getKey();
			value = entry.getValue();
		} else {
			key = (K)it.next();
			value = defaultVal;
		}
	} else { // use stream
		key = (K) str.readObject();
		value = (defaultVal != null ? defaultVal : (V) str.readObject());
	}
	// åˆ›å»ºmiddleèŠ‚ç‚¹
	Entry<K,V> middle =  new Entry<>(key, value, null);
 
	// è‹¥å½“å‰èŠ‚ç‚¹çš„æ·±åº¦=çº¢è‰²èŠ‚ç‚¹çš„æ·±åº¦ï¼Œåˆ™å°†èŠ‚ç‚¹ç€è‰²ä¸ºçº¢è‰²ã€‚
	if (level == redLevel)
		middle.color = RED;
	// è®¾ç½®middleä¸ºleftçš„çˆ¶äº²ï¼Œleftä¸ºmiddleçš„å·¦å­©å­
	if (left != null) {
		middle.left = left;
		left.parent = middle;
	}
 
	if (mid < hi) {
		// é€’å½’è°ƒç”¨è·å–(middelçš„)å³å­©å­ã€‚
		Entry<K,V> right = buildFromSorted(level+1, mid+1, hi, redLevel,
										   it, str, defaultVal);
		// è®¾ç½®middleä¸ºleftçš„çˆ¶äº²ï¼Œleftä¸ºmiddleçš„å·¦å­©å­
		middle.right = right;
		right.parent = middle;
	}
 
	return middle;
}

/**
 * è®¡ç®—èŠ‚ç‚¹æ ‘ä¸ºszçš„æœ€å¤§æ·±åº¦ï¼Œä¹Ÿæ˜¯çº¢è‰²èŠ‚ç‚¹çš„æ·±åº¦å€¼ã€‚
 */
private static int computeRedLevel(int sz) {
	int level = 0;
	for (int m = sz - 1; m >= 0; m = m / 2 - 1)
		level++;
	return level;
}
```
- éå†æ–¹å¼

```
TreeMapçš„éå†æ–¹å¼ä¸€èˆ¬åˆ†ä¸ºä¸¤æ­¥ï¼š
1. å…ˆé€šè¿‡entrySet()æˆ–keySet()æˆ–value()æ–¹æ³•è·å¾—ç›¸åº”çš„é›†åˆï¼›
2. é€šè¿‡Iteratorè¿­ä»£å™¨éå†ä¸Šé¢å¾—åˆ°çš„é›†åˆã€‚
```
1. éå† TreeMap çš„ Entry

```
TreeMap treeMap = new TreeMap();
Object key = null, value = null;;
Iterator iterator = treeMap.entrySet().iterator();
while(iterator.hasNext()) {
    Map.Entry entry = (Map.Entry)iterator.next();
    // è·å–key
    key =  entry.getKey();
    // è·å–value
    value = entry.getValue();
}
```

2. éå† TreeMap çš„ key

```
TreeMap treeMap = new TreeMap();
Object key = null, value = null;;
Iterator iterator = treeMap.keySet().iterator();
while(iterator.hasNext()) {
    key = iterator.next();
    // è·å–key
    key =  entry.getKey();
    // è·å–value
    value = treeMap.get(key);
}
```

3. éå† TreeMap çš„ value

```
TreeMap treeMap = new TreeMap();
Object value = null;;
Collection c = map.values();
Iterator iterator= c.iterator();
while (iter.hasNext()) {
    value = iterator.next();
}
```

**ç»¼ä¸Šæ‰€è¿°ï¼Œ `TreeMap` åŸºæœ¬ä¸Šå°±ä»‹ç»å®Œäº†ï¼Œå¸Œæœ›å¯¹å¤§å®¶æœ‰æ‰€å¸®åŠ©ï¼ï¼ï¼**

----

> æ–‡ç« å¯ä»¥ç™½å«–ï¼Œè€é“ä»¬é¡ºä¾¿å…³æ³¨ä¸€ä¸‹æˆ‘çš„å…¬ä¼—å·ï¼Œæ‰‹åŠ¨æ»‘ç¨½ğŸ¤£ğŸ¤£ &nbsp;
>
> æ¬¢è¿å¤§å®¶å…³æ³¨ï¼š**æ­¦å“¥èŠç¼–ç¨‹**ã€**Javaå¼€å‘å®å…¸**ã€**Javaç§ƒå¤´å“¥**ï¼Œæ‚¨çš„æ”¯æŒï¼Œæ˜¯æˆ‘åˆ›ä½œçš„æŒç»­åŠ¨åŠ›ï¼&nbsp;&nbsp;

![å…¬ä¼—å·äºŒç»´ç ](https://img-blog.csdnimg.cn/20201121225359995.png)
